// OIL-Definition-File
OIL_VERSION = "2.3";

#include <TMS470R1.I23>

CPU dummy {
   #include <TMS470R1.s23>

   OS StdOS {
      CC = AUTO;
      STATUS = EXTENDED;
      SCHEDULE = AUTO;
      STARTUPHOOK = TRUE: "will be used to activate InitTask";
      ERRORHOOK = TRUE: "will be used to report OSEK errors";
      SHUTDOWNHOOK = FALSE;
      PRETASKHOOK = FALSE: "will be used for runtime measurement";
      POSTTASKHOOK = FALSE;
      USEGETSERVICEID = TRUE;
      USEPARAMETERACCESS = FALSE;
      SystemStackSize = 300;
      WithStackCheck = TRUE;
      CpuFrequency = 60.000000: "CPU clock frequency is (15MHz / 2) * 8";
      TimerClockDivider = AUTO;
      TickTime = 1000: "Tick Time will used in ms";
      SystemTimer = COMP1: "SystemTimer Comp1 will be used";
      UseGeneratedFastAlarm = FALSE;
      SupervisorStackSize = 200;
      StartupStackSize = 200: "Stack size for startupHook and PreTaskHook";
      IRQMaxNesting = 4;
      IRQStackOffset = 200;
      NotUsingRES_SCHEDULER = FALSE;
      ThumbMode = FALSE;
      UseRegistersForOS = FALSE;
      UDEFHandler = AUTO;
      SWIHandler = AUTO;
      PABTHandler = AUTO;
      DABTHandler = AUTO;
      FIQHandler = AUTO;
      NoFIQVector = FALSE;
      GHSDebugSupport = FALSE;
      ORTIDebugLevel = ORTI_21_Additional;
      ErrorInfoLevel = STANDARD;
      OSInternalChecks = Additional;
      Compiler = TI;
      ORTIDebugSupport = FALSE;
      APIOptimization = Automatic;
   }: "Standard object for operating system configuration";

   TASK OsHostTask_10ms {
      TYPE = AUTO;
      SCHEDULE = NON: "this Task can not be scheduled";
      PRIORITY = 10: "highest Priority Task during runtime";
      ACTIVATION = 1: "it can be activated only for one instance";
      AUTOSTART = TRUE
      {
         APPMODE = OSDEFAULTAPPMODE;
      };
      EVENT = evActivateHostTask_10ms;
      EVENT = evHostTaskDiagnoseResponse;
      EVENT = evHostTaskOnCshdlRequestToCan;
      EVENT = evHostTaskHandleDiagReq;
      EVENT = evHostTask_INFO_Response;
      RESOURCE = UART_LockResource;
      RESOURCE = EEPROM_LockResource;
      RESOURCE = POOL_LockResource;
      RESOURCE = DEH_LockResource;
      RESOURCE = EEPROM_LAYOUT_LockResource;
      ACCESSOR = SENT
      {
         MESSAGE = msgCshdl_Requests;
         WITHOUTCOPY = FALSE;
         ACCESSNAME = "SentBSGmessageType";
         DoNotGenerateBuffer = FALSE;
      };
      ACCESSOR = RECEIVED
      {
         MESSAGE = msgAppDiagDiagnoseResponse;
         WITHOUTCOPY = FALSE;
         ACCESSNAME = "RecAppDiagResp";
         DoNotGenerateBuffer = FALSE;
      };
      ACCESSOR = SENT
      {
         MESSAGE = msgAppDiagDiagnoseRequest;
         WITHOUTCOPY = FALSE;
         ACCESSNAME = "SentAppDiagReq";
         DoNotGenerateBuffer = FALSE;
      };
      ACCESSOR = RECEIVED
      {
         MESSAGE = msgCshdlRequestToCan;
         WITHOUTCOPY = FALSE;
         ACCESSNAME = "ReceivedMessage_Cshdl_To_Can";
         DoNotGenerateBuffer = FALSE;
      };
      ACCESSOR = SENT
      {
         MESSAGE = msgInfo_Requests;
         WITHOUTCOPY = FALSE;
         ACCESSNAME = "CanRx_INFO_SentMsgData";
         DoNotGenerateBuffer = FALSE;
      };
      ACCESSOR = RECEIVED
      {
         MESSAGE = msgInfo_Responses;
         WITHOUTCOPY = FALSE;
         ACCESSNAME = "CanTx_INFO_ReceivedMsgData";
         DoNotGenerateBuffer = FALSE;
      };
      StackSize = 600;
      NotUsingSchedule = FALSE;
   }: "Task for CAN specific funktions, which must be called cyclic all 10ms";

   TASK OsAppTask_event_100ms {
      TYPE = AUTO;
      SCHEDULE = FULL: "this Task can be scheduled";
      PRIORITY = 8: "Priority 8";
      ACTIVATION = 1: "it can be activated only for one instance";
      AUTOSTART = FALSE;
      EVENT = evActivateAppTask_event_100ms;
      EVENT = evAppTaskERMPending;
      EVENT = evAppTaskDiagnoseRequest;
      EVENT = evAppTaskDeviceFctPending;
      EVENT = evAppTaskVCRSupervisor;
      EVENT = evAppTaskSystemStates;
      EVENT = evAppTaskApplResponse;
      EVENT = evAppTask_INFO_Request;
      RESOURCE = CK5050_WRITE_Resource;
      RESOURCE = UART_LockResource;
      RESOURCE = EEPROM_LockResource;
      RESOURCE = POOL_LockResource;
      RESOURCE = DEH_LockResource;
      RESOURCE = EEPROM_LAYOUT_LockResource;
      ACCESSOR = RECEIVED
      {
         MESSAGE = msgAppDiagDiagnoseRequest;
         WITHOUTCOPY = FALSE;
         ACCESSNAME = "RecAppDiagReq";
         DoNotGenerateBuffer = FALSE;
      };
      ACCESSOR = RECEIVED
      {
         MESSAGE = msgAppTaskSystemStates;
         WITHOUTCOPY = FALSE;
         ACCESSNAME = "RecCSHDL_enSystemStates";
         DoNotGenerateBuffer = FALSE;
      };
      ACCESSOR = RECEIVED
      {
         MESSAGE = msgInfo_Requests;
         WITHOUTCOPY = FALSE;
         ACCESSNAME = "CanTx_INFO_ReceiveMsgData";
         DoNotGenerateBuffer = FALSE;
      };
      ACCESSOR = SENT
      {
         MESSAGE = msgInfo_Responses;
         WITHOUTCOPY = FALSE;
         ACCESSNAME = "CanTx_INFO_SentMsgData";
         DoNotGenerateBuffer = FALSE;
      };
      ACCESSOR = SENT
      {
         MESSAGE = msgAppDiagDiagnoseResponse;
         WITHOUTCOPY = FALSE;
         ACCESSNAME = "SetAppDiagReq";
         DoNotGenerateBuffer = FALSE;
      };
      ACCESSOR = RECEIVED
      {
         MESSAGE = msgApplResponse;
         WITHOUTCOPY = FALSE;
         ACCESSNAME = "RecvApplResponse";
         DoNotGenerateBuffer = FALSE;
      };
      StackSize = 600;
      NotUsingSchedule = FALSE;
   }: "Task to handle the comunication between BAP, TMS470 and CK5050+";

   TASK OsSystemTask_event {
      TYPE = AUTO;
      SCHEDULE = NON: "this Task can not be scheduled";
      PRIORITY = 7: "Priority 7";
      ACTIVATION = 1: "it can be activated only for one instance";
      AUTOSTART = FALSE;
      EVENT = evSystemTaskShutdown;
      EVENT = evSystemTaskVoltageState;
      EVENT = evSystemTask_CSHDL_Request;
      EVENT = evSystemTaskCallbackShutdown;
      EVENT = evActivateSystemTask_event;
      RESOURCE = UART_LockResource;
      RESOURCE = DEH_LockResource;
      RESOURCE = EEPROM_LAYOUT_LockResource;
      RESOURCE = EEPROM_LockResource;
      ACCESSOR = RECEIVED
      {
         MESSAGE = msgPwrmgrState;
         WITHOUTCOPY = FALSE;
         ACCESSNAME = "RecPWMGR_enVoltageStates";
         DoNotGenerateBuffer = FALSE;
      };
      ACCESSOR = RECEIVED
      {
         MESSAGE = msgCshdl_Requests;
         WITHOUTCOPY = FALSE;
         ACCESSNAME = "CanRx_CSHDL_ReceivedMsgData";
         DoNotGenerateBuffer = FALSE;
      };
      ACCESSOR = SENT
      {
         MESSAGE = msgAppTaskSystemStates;
         WITHOUTCOPY = FALSE;
         ACCESSNAME = "SentCSHDL_enSystemStates";
         DoNotGenerateBuffer = FALSE;
      };
      ACCESSOR = SENT
      {
         MESSAGE = msgCshdlRequestToCan;
         WITHOUTCOPY = FALSE;
         ACCESSNAME = "SentMessage_Cshdl_To_Can";
         DoNotGenerateBuffer = FALSE;
      };
      StackSize = 240;
      NotUsingSchedule = FALSE;
   }: "working place for CentralStateHandler";

   TASK OsDriverTask_1ms {
      TYPE = AUTO;
      SCHEDULE = FULL: "this Task can be scheduled";
      PRIORITY = 4: "Priority 4";
      ACTIVATION = 1: "it can be activated only for one instance";
      AUTOSTART = FALSE;
      EVENT = evActivateDriverTask_1ms;
      RESOURCE = UART_LockResource;
      RESOURCE = POOL_LockResource;
      RESOURCE = DEH_LockResource;
      RESOURCE = EEPROM_LockResource;
      RESOURCE = EEPROM_LAYOUT_LockResource;
      ACCESSOR = SENT
      {
         MESSAGE = msgApplResponse;
         WITHOUTCOPY = FALSE;
         ACCESSNAME = "SentApplResponse";
         DoNotGenerateBuffer = FALSE;
      };
      StackSize = 380;
      NotUsingSchedule = FALSE;
   }: "cyclic Task for receiving AT commands from CK5050+";

   TASK OsMonitorTask_50ms {
      TYPE = AUTO;
      SCHEDULE = FULL: "this Task can be scheduled";
      PRIORITY = 2: "Priority 2";
      ACTIVATION = 1: "it can be activated only for one instance";
      AUTOSTART = FALSE;
      EVENT = evActivateMonitorTask_50ms;
      EVENT = evMonitorTask_MonitorAudio_for_DTC;
      RESOURCE = UART_LockResource;
      RESOURCE = CRC_LockResource;
      RESOURCE = DEH_LockResource;
      RESOURCE = EEPROM_LockResource;
      RESOURCE = EEPROM_LAYOUT_LockResource;
      ACCESSOR = SENT
      {
         MESSAGE = msgPwrmgrState;
         WITHOUTCOPY = FALSE;
         ACCESSNAME = "SentPWMGR_enVoltageStates";
         DoNotGenerateBuffer = FALSE;
      };
      StackSize = 260;
      NotUsingSchedule = FALSE;
   }: "Handling of Power- and Temperaturemanagement";

   TASK OsDatabaseTask_event {
      TYPE = AUTO;
      SCHEDULE = FULL: "this Task can be scheduled";
      PRIORITY = 1: "Priority 1";
      ACTIVATION = 1: "it can be activated only for one instance";
      AUTOSTART = FALSE;
      EVENT = evDatabaseCyclicEepromWrite;
      EVENT = evTriggerWD;
      RESOURCE = EEPROM_LockResource;
      RESOURCE = UART_LockResource;
      RESOURCE = DEH_LockResource;
      RESOURCE = EEPROM_LAYOUT_LockResource;
      StackSize = 200;
      NotUsingSchedule = FALSE;
   }: "Handling of the EEProm writing";

   ALARM CTA_HOST {
      COUNTER = SystemTimer;
      ACTION = SETEVENT
      {
         TASK = OsHostTask_10ms;
         EVENT = evActivateHostTask_10ms;
      }: "Task is in waiting state, till the event will be set by Alarm";
      AUTOSTART = FALSE
      {
         StaticAlarm = FALSE;
      };
   }: "Alarm to activate the HostTask_10ms all 10ms with an event.";

   ALARM CTA_MONITOR {
      COUNTER = SystemTimer;
      ACTION = SETEVENT
      {
         TASK = OsMonitorTask_50ms;
         EVENT = evActivateMonitorTask_50ms;
      }: "Task is in waiting state, till the event will be set by Alarm";
      AUTOSTART = FALSE
      {
         StaticAlarm = FALSE;
      };
   }: "Alarm to activate the MonitorTask_50ms all 50ms with an event.";

   ALARM CTA_DRIVER {
      COUNTER = SystemTimer;
      ACTION = SETEVENT
      {
         TASK = OsDriverTask_1ms;
         EVENT = evActivateDriverTask_1ms;
      }: "Task is in waiting state, till the event will be set by Alarm";
      AUTOSTART = FALSE
      {
         StaticAlarm = FALSE;
      };
   }: "Alarm to activate the DriverTask_1ms all 1ms with an event.";

   ALARM CTA_DATABASE_EEPROM_WRITE {
      COUNTER = SystemTimer;
      ACTION = SETEVENT
      {
         TASK = OsDatabaseTask_event;
         EVENT = evDatabaseCyclicEepromWrite;
      };
      AUTOSTART = FALSE
      {
         StaticAlarm = FALSE;
      };
   }: "sets an event to cyclically write EEPROM pagewise";

   ALARM CTA_APP {
      COUNTER = SystemTimer;
      ACTION = SETEVENT
      {
         TASK = OsAppTask_event_100ms;
         EVENT = evActivateAppTask_event_100ms;
      };
      AUTOSTART = FALSE
      {
         StaticAlarm = FALSE;
      };
   }: "if AppTask_event_5ms detect that any more jobs must be done he activate this alarm.";

   ALARM CTA_SYSTEM {
      COUNTER = SystemTimer;
      ACTION = SETEVENT
      {
         TASK = OsSystemTask_event;
         EVENT = evActivateSystemTask_event;
      };
      AUTOSTART = FALSE
      {
         StaticAlarm = FALSE;
      };
   }: "activate the SystemTask_event cyclic";

   ALARM CTA_ERM_PENDING {
      COUNTER = SystemTimer;
      ACTION = SETEVENT
      {
         TASK = OsAppTask_event_100ms;
         EVENT = evAppTaskERMPending;
      };
      AUTOSTART = FALSE
      {
         StaticAlarm = FALSE;
      };
   }: "used to indicate that there are additional things to be done for VCR";

   ALARM CTA_WD {
      COUNTER = SystemTimer;
      ACTION = SETEVENT
      {
         TASK = OsDatabaseTask_event;
         EVENT = evTriggerWD;
      };
      AUTOSTART = FALSE
      {
         StaticAlarm = FALSE;
      };
   };

   ALARM CTA_MONITOR_AUDIO {
      COUNTER = SystemTimer;
      ACTION = SETEVENT
      {
         TASK = OsMonitorTask_50ms;
         EVENT = evMonitorTask_MonitorAudio_for_DTC;
      };
      AUTOSTART = FALSE
      {
         StaticAlarm = FALSE;
      };
   }: "Alarm to set event for DTCs.";

   ALARM CTA_ONE_HOUR_MODE {
      COUNTER = SystemTimer;
      ACTION = ALARMCALLBACK
      {
         ALARMCALLBACKNAME = "CSHDL_cbAlarmCallbackOneHourModeOver";
      };
      AUTOSTART = FALSE
      {
         StaticAlarm = FALSE;
      };
   }: "One Hour Timer.";

   ALARM CTA_APP_DIAG_WAIT_FOR_APP_CB {
      COUNTER = SystemTimer;
      ACTION = ALARMCALLBACK
      {
         ALARMCALLBACKNAME = "APP_DIAG_vHandlePendingResponseFromApplication";
      };
      AUTOSTART = FALSE
      {
         StaticAlarm = FALSE;
      };
   };

   ALARM CTA_APP_DIAG_RETRY_BUSY {
      COUNTER = SystemTimer;
      ACTION = SETEVENT
      {
         TASK = OsAppTask_event_100ms;
         EVENT = evAppTaskDiagnoseRequest;
      };
      AUTOSTART = FALSE
      {
         StaticAlarm = FALSE;
      };
   };

   ALARM CTA_HOST_HANDLE_DIAG_REQ {
      COUNTER = SystemTimer;
      ACTION = SETEVENT
      {
         TASK = OsHostTask_10ms;
         EVENT = evHostTaskHandleDiagReq;
      };
      AUTOSTART = FALSE
      {
         StaticAlarm = FALSE;
      };
   };

   ALARM CTA_HOST_SELF_DIAG_TIMER {
      COUNTER = SystemTimer;
      ACTION = ALARMCALLBACK
      {
         ALARMCALLBACKNAME = "APP_CAN_cbHostSelfDiagnosisTimer";
      };
      AUTOSTART = FALSE
      {
         StaticAlarm = FALSE;
      };
   };

   RESOURCE CK5050_WRITE_Resource {
      RESOURCEPROPERTY = STANDARD;
   }: "Resource to save the writing for the AT commands from TMS470 to CK5050+";

   RESOURCE EEPROM_LockResource {
      RESOURCEPROPERTY = STANDARD;
   }: "Resource to save the EEProm write";

   RESOURCE UART_LockResource {
      RESOURCEPROPERTY = STANDARD;
   }: "resource to lock / release in DEBUG_Printf to save debug comments from task with lower priority";

   RESOURCE CRC_LockResource {
      RESOURCEPROPERTY = STANDARD;
   }: "Resource to save the CRC";

   RESOURCE POOL_LockResource {
      RESOURCEPROPERTY = STANDARD;
   }: "resource for Poll handling";

   RESOURCE DEH_LockResource {
      RESOURCEPROPERTY = STANDARD;
   }: "Lock DTC Report Event call";

   RESOURCE EEPROM_LAYOUT_LockResource {
      RESOURCEPROPERTY = STANDARD;
   }: "To avoid inconsistency between the ram data and the E2P data.";

   EVENT evActivateHostTask_10ms {
      MASK = AUTO;
   }: "Event to activate the HostTask_10ms";

   EVENT evActivateMonitorTask_50ms {
      MASK = AUTO;
   }: "Event to activate the MonitortTask_50ms";

   EVENT evActivateDriverTask_1ms {
      MASK = AUTO;
   }: "Event to activate the DriverTask_1ms";

   EVENT evActivateAppTask_event_100ms {
      MASK = AUTO;
   }: "Event to activate App task cyclically 100ms";

   EVENT evDatabaseCyclicEepromWrite {
      MASK = AUTO;
   }: "event to cyclically write EEPROM pagewise";

   EVENT evActivateSystemTask_event {
      MASK = AUTO;
   }: "event to activate the SystemTask_event";

   EVENT evSystemTaskShutdown {
      MASK = AUTO;
   }: "event to set the power down state!";

   EVENT evSystemTaskVoltageState {
      MASK = AUTO;
   }: "signed that a new voltage state has occured";

   EVENT evSystemTask_CSHDL_Request {
      MASK = AUTO;
   };

   EVENT evAppTaskERMPending {
      MASK = AUTO;
   };

   EVENT evTriggerWD {
      MASK = AUTO;
   };

   EVENT evHostTaskDiagnoseResponse {
      MASK = AUTO;
   };

   EVENT evAppTaskDiagnoseRequest {
      MASK = AUTO;
   };

   EVENT evMonitorTask_MonitorAudio_for_DTC {
      MASK = AUTO;
   };

   EVENT evAppTaskDeviceFctPending {
      MASK = AUTO;
   };

   EVENT evAppTaskVCRSupervisor {
      MASK = AUTO;
   };

   EVENT evAppTaskSystemStates {
      MASK = AUTO;
   };

   EVENT evSystemTaskCallbackShutdown {
      MASK = AUTO;
   }: "callback event from AppTask it disconnect is OK";

   EVENT evAppTaskApplResponse {
      MASK = AUTO;
   };

   EVENT evHostTaskOnCshdlRequestToCan {
      MASK = AUTO;
   };

   EVENT evHostTaskHandleDiagReq {
      MASK = AUTO;
   };

   EVENT evHostTask_INFO_Response {
      MASK = AUTO;
   };

   EVENT evAppTask_INFO_Request {
      MASK = AUTO;
   };

   ISR CanIsr_0 {
      CATEGORY = 2;
      InterruptSource = HECCA;
   }: "Interrupt for Standard Can Controller 1";

   ISR UART1_TxISR {
      CATEGORY = 1;
      InterruptSource = SCITX;
   }: "Interrupt Service Routine for UART transmit";

   ISR UART1_RxISR {
      CATEGORY = 1;
      InterruptSource = SCIRX;
   }: "Interrupt Service Routine for UART receive";

   ISR UART2_TxISR {
      CATEGORY = 1;
      InterruptSource = EXT26;
   }: "Interrupt Service Routine for UART 2 transmit";

   ISR UART2_RxISR {
      CATEGORY = 1;
      InterruptSource = EXT17;
   }: "Interrupt Service Routine for UART 2 receive";

   ISR UART_ErrorISR {
      CATEGORY = 1;
      InterruptSource = SCIERR;
   }: "Interrupt Service Routine for UART errors";

   MESSAGE msgPwrmgrState {
      TYPE = UNQUEUED;
      CDATATYPE = "PWMGR_enVoltageStates";
      ACTION = SETEVENT
      {
         TASK = OsSystemTask_event;
         EVENT = evSystemTaskVoltageState;
      };
   }: "message to signal the Voltage area to the CSHDL";

   MESSAGE msgCshdl_Requests {
      TYPE = QUEUED
      {
         QUEUEDEPTH = 7;
      };
      CDATATYPE = "CanRequests_CSHDL_MsgType";
      ACTION = SETEVENT
      {
         TASK = OsSystemTask_event;
         EVENT = evSystemTask_CSHDL_Request;
      };
   };

   MESSAGE msgAppDiagDiagnoseResponse {
      TYPE = UNQUEUED;
      CDATATYPE = "APP_DIAG_ST_DIAG_RESPONSE";
      ACTION = SETEVENT
      {
         TASK = OsHostTask_10ms;
         EVENT = evHostTaskDiagnoseResponse;
      };
   };

   MESSAGE msgAppDiagDiagnoseRequest {
      TYPE = UNQUEUED;
      CDATATYPE = "APP_DIAG_ST_DIAG_REQUEST";
      ACTION = SETEVENT
      {
         TASK = OsAppTask_event_100ms;
         EVENT = evAppTaskDiagnoseRequest;
      };
   };

   MESSAGE msgAppTaskSystemStates {
      TYPE = QUEUED
      {
         QUEUEDEPTH = 2;
      };
      CDATATYPE = "CSHDL_enSystemStates";
      ACTION = SETEVENT
      {
         TASK = OsAppTask_event_100ms;
         EVENT = evAppTaskSystemStates;
      };
   };

   MESSAGE msgCshdlRequestToCan {
      TYPE = UNQUEUED;
      CDATATYPE = "CSHDL_ENUM_REQUEST_TO_CAN";
      ACTION = SETEVENT
      {
         TASK = OsHostTask_10ms;
         EVENT = evHostTaskOnCshdlRequestToCan;
      };
   }: "This message is send by CSHDL and is to be received by Host Task";

   MESSAGE msgInfo_Responses {
      TYPE = QUEUED
      {
         QUEUEDEPTH = 4;
      };
      CDATATYPE = "CanResponses_INFO_MsgType";
      ACTION = SETEVENT
      {
         TASK = OsHostTask_10ms;
         EVENT = evHostTask_INFO_Response;
      };
   };

   MESSAGE msgInfo_Requests {
      TYPE = QUEUED
      {
         QUEUEDEPTH = 4;
      };
      CDATATYPE = "CanRequests_INFO_MsgType";
      ACTION = SETEVENT
      {
         TASK = OsAppTask_event_100ms;
         EVENT = evAppTask_INFO_Request;
      };
   };

   MESSAGE msgApplResponse {
      TYPE = QUEUED
      {
         QUEUEDEPTH = 6;
      };
      CDATATYPE = "ApplRspMessageType";
      ACTION = SETEVENT
      {
         TASK = OsAppTask_event_100ms;
         EVENT = evAppTaskApplResponse;
      };
   };

   COM StdCOM {
      USEMESSAGERESOURCE = TRUE;
      USEMESSAGESTATUS = TRUE;
   }: "Standard object for communication configuration";

}: "@T0x78@";

