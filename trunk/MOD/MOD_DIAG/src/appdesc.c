/* -----------------------------------------------------------------------------
  Filename:    appdesc.c
  Description: Implementation example for the proper usage with CANdesc.
                
                Manufacturer: Porsche AG
                EcuDocFile:   C:\DOKUME~1\rammelt\LOKALE~1\Temp\CANdescBasic0.desc
                Variant:      CommonDiagnostics

  Generated by CANdelaGen, Thu Oct 20 11:18:11 2011
 
 ----------------------------------------------------------------------------- */
/* -----------------------------------------------------------------------------
  C O P Y R I G H T
 -------------------------------------------------------------------------------
  Copyright (c) 2001-2010 by Vector Informatik GmbH. All rights reserved.
 
  This software is copyright protected and proprietary to Vector Informatik 
  GmbH.
  
  Vector Informatik GmbH grants to you only those rights as set out in the 
  license conditions.
  
  All other rights remain with Vector Informatik GmbH.
 -------------------------------------------------------------------------------
 ----------------------------------------------------------------------------- */

/* -----------------------------------------------------------------------------
    &&&~ History
 ----------------------------------------------------------------------------- */

/* ----------------------------------------------------------------------------
  Please note, that the demo and example programs only show special aspects of 
  the software. With regard to the fact that these programs are meant for 
  demonstration purposes only, Vector Informatik´s liability shall be expressly 
  excluded in cases of ordinary negligence, to the extent admissible by law or 
  statute.
  ---------------------------------------------------------------------------- */

/* 
------------------------------------------------------------------------------------------------------------------------
                                             A U T H O R   I D E N T I T Y                                              
------------------------------------------------------------------------------------------------------------------------
Initials   Name                  Company                                                                                
---------- --------------------- ---------------------------------------------------------------------------------------
Ktw        Katrin Thurow         Vector Informatik GmbH                                                                 
Mhe        Matthias Heil         Vector Informatik GmbH                                                                 
Sa         Mishel Shishmanyan    Vector Informatik GmbH                                                                 
------------------------------------------------------------------------------------------------------------------------
                                            R E V I S I O N   H I S T O R Y                                             
------------------------------------------------------------------------------------------------------------------------
Date       Version  Author Modification type Issue Id      Affects                        Description                    
---------- -------- ------ ----------------- ------------- ------------------------------ -------------------------------
2006-10-20 05.00.00
                    Sa     Modified          ESCAN00016884 UDS                            ComControl service compliance with the latest ISO-UDS (2005-05-29).
                    Sa     Modified          ESCAN00018098 All                            Unified security access management and API.
                    Sa     Added             ESCAN00017752 All                            OBD II compliance with regard to the NRC usage and response behavior.
                    Sa     Added             ESCAN00018099 All                            Add support for CANdela format 5.0.
2007-02-16 05.01.00
                    Sa     Fixed             ESCAN00018114 Porsche AG(UDS)                CANdesc not compilable if permanent repeated call is turned on.
                    Sa     Fixed             ESCAN00018916 Porsche AG(UDS)                Compile error on multi-channel system and service $28 support.
                    Sa     Modified          ESCAN00019645 Porsche AG(UDS)                API DescSendPosRespFBL can send wrong response if illegal parameter value used.
                    Sa     Fixed             ESCAN00018576 All                            Service instance linear look-up routine fails finding a requested service.
                    Sa     Fixed             ESCAN00019220 All                            Compile error for wrong syntax after preprocesing defines: DescUsdtNetStateTask and DescUsdtNetTimerTask.
                    Sa     Fixed             ESCAN00019334 All                            Generator: Unable to generate CANdesc with multi channel TP and CANgen newer than 4.30.03.
                    Sa     Modified          ESCAN00018872 All                            Wrong main-handler comment for constants names kDescReqTypePhys (-Func).
                    Sa     Modified          ESCAN00019321 All                            Remove file-path from the #include "node.h"
                    Sa     Modified          ESCAN00019735 All                            Use CPU type optimized data definition types (uintx_least).
                    Sa     Added             ESCAN00018320 All                            Generate P2 and P2* task-call constants with a justification of one task call less.
                    Sa     Added             ESCAN00018592 All                            DescRingBufferCancel API added.
2007-04-13 05.02.00
                    Sa     Modified          ESCAN00020245 Porsche AG(UDS)                Unusable API DescTransmitSingleFrame declared.
                    Sa     Added             ESCAN00020069 UDS                            Support for unified PID application handling.
2007-05-30 05.03.00
                    Sa     Fixed             ESCAN00020975 Porsche AG(UDS)                Rapid shut-down left on service $11 $04
                    Sa     Fixed             ESCAN00020760 UDS                            Service $22 responds with wrong NRC $13 instead of $31 in case single DID mode has been selected
                    Sa     Modified          ESCAN00020840 All                            Compiler error message on local variable pointer to ROM using V_MEMROM0 define
                    Sa     Modified          ESCAN00019437 All                            Compiler error in desc.c with mem-model huge
2007-07-23 05.04.00
                    Sa     Added             ESCAN00021530 UDS                            Support for custom rx communication path handling on service $28
                    Sa     Fixed             ESCAN00021336 All                            use lower case characters for names of generated files (AppDesc.h => appdesc.h)
                    Sa     Modified          ESCAN00021523 All                            Removed the first frame length dependency on Vector TP for for ring-buffer usage
                    Sa     Added             ESCAN00021528 All                            Stopping RepeatedServiceCall in RingBufferCancel
                    Sa     Added             ESCAN00021567 All                            Use case catch on RingBuffer usage with SPRMIB=1
2007-09-07 05.05.00
                    Sa     Added             ESCAN00022078 Porsche AG(UDS)                Compliance to PAG specification version 1.5
                    Sa     Fixed             ESCAN00021610 UDS                            Incorrect NRC on an invalidly formatted writeDataByIdentifier ($2e) request for non-writeable DID
                    Sa     Fixed             ESCAN00021615 UDS                            Incorrect NRC on service with parameter identifier not supported in active session
                    Sa     Fixed             ESCAN00021800 UDS                            Wrong response lenght on service $22 in single DID mode
                    Sa     Added             ESCAN00022074 UDS                            Unified PID support on service $2E
                    Sa     Added             ESCAN00022075 UDS                            Unified PID support on service $22 in single PID mode
                    Sa     Fixed             ESCAN00022068 All                            Include appDesc.h changed to appdesc.h
                    Sa     Modified          ESCAN00021654 All                            Explicit suppression of NRC $11 on functional request
                    Sa     Modified          ESCAN00021252 All                            Compiler warnings for unreferenced variable and function declaration
                    Sa     Modified          ESCAN00022254 All                            Adaptions for the interrupt support of the latest VStdLib version
                    Sa     Added             ESCAN00021847 All                            Access to the current communication parameters
2007-10-22 05.05.01
                    Sa     Modified          ESCAN00022853 UDS                            Allow for service $10 the P2 time report not to be present
2007-10-26 05.05.02
                    -      -                 -             -                              No relevant changes available in this version.
2007-11-15 05.05.03
                    Sa     Added             ESCAN00023231 All                            Support multiple ECU numbers   
2007-12-17 05.05.04
                    -      -                 -             -                              No relevant changes available in this version.
2007-12-20 05.06.00
                    Sa     Modified          ESCAN00022853 UDS                            Allow for service $10 the P2 time report not to be present
                    Sa     Modified          ESCAN00022868 UDS                            Consider CDD files having only SID based information (CANdescBasic like)
                    Sa     Added             ESCAN00023231 All                            Support multiple ECU numbers   
2008-01-22 05.06.01
                    Sa     Modified          ESCAN00024147 UDS                            Specify suppressPosRes DescMsgContext member as read-only item and not read-write
                    Sa     Fixed             ESCAN00026046 All                            CANdesc responds on wrong CAN Id
                    Mhe    Added             ESCAN00024011 All                            Support dynamic normal addressing
                    Mhe    Added             ESCAN00024019 All                            Support far RAM Tp API         
2008-02-04 05.06.02
                    -      -                 -             -                              No relevant changes available in this version.
2008-01-11 05.06.03
                    -      -                 -             -                              No relevant changes available in this version.
2008-03-14 05.06.04
                    Mhe    Added             ESCAN00024951 UDS                            Internal support for read/write memory by address
                    Sa     Added             ESCAN00024929 UDS                            Allow unified PID handling for service $22 without multiple PID support
2008-04-03 05.06.05
                    Sa     Fixed             ESCAN00025393 Porsche AG(UDS)                Compile error on function call 'DescSendSpontaneousResponse'
                    Sa     Fixed             ESCAN00025753 UDS                            Supported PIDs will not be recognized if service $2F is also available in the system
2008-04-21 05.06.06
                    Sa     Fixed             ESCAN00026335 All                            Compile error with DynamicTP   
2008-05-23 05.06.07
                    Sa     Fixed             ESCAN00027058 UDS                            Compile error on generated main-handler with ring-buffer access an single PID mode
                    Sa     Fixed             ESCAN00026907 All                            On TMS320 wrong vstdlib memcopy API used
                    Sa     Fixed             ESCAN00027059 All                            Array out of boundary access error on generated main-handler with ring-buffer access
                    Sa     Modified          ESCAN00027061 All                            Minor DescICN driver optimization
                    Sa     Modified          ESCAN00027063 All                            MainHandler req-/resDataLen has misleading description for CANdescBasic
                    Ktw    Modified          ESCAN00027057 All                            Compile error on missing semicolon for DescSetNpmOnCanChannelActive macro expansion
                    Mhe    Added             ESCAN00026452 All                            Posthandler support for generated $23
2008-05-26 05.06.08
                    Sa     Fixed             ESCAN00027060 UDS                            Wrong assertion in case of negative response on service 0x22 and multiple PID mode
                    Sa     Fixed             ESCAN00027085 UDS                            Compile error on configurations without service $2A or $2C
                    Sa     Fixed             ESCAN00027084 All                            Compile error on non TMS320 platforms
2008-06-05 05.06.09
                    -      -                 -             -                              No relevant changes available in this version.
2008-06-16 05.06.10
                    -      -                 -             -                              No relevant changes available in this version.
2008-06-27 05.07.00
                    Sa     Fixed             ESCAN00027058 UDS                            Compile error on generated main-handler with ring-buffer access an single PID mode
                    Sa     Fixed             ESCAN00027060 UDS                            Wrong assertion in case of negative response on service 0x22 and multiple PID mode
                    Sa     Modified          ESCAN00024147 UDS                            Specify suppressPosRes DescMsgContext member as read-only item and not read-write
                    Sa     Added             ESCAN00024929 UDS                            Allow unified PID handling for service $22 without multiple PID support
                    Mhe    Added             ESCAN00024951 UDS                            Internal support for read/write memory by address
                    Sa     Fixed             ESCAN00026046 All                            CANdesc responds on wrong CAN Id
                    Sa     Fixed             ESCAN00026907 All                            On TMS320 wrong vstdlib memcopy API used
                    Sa     Fixed             ESCAN00027059 All                            Array out of boundary access error on generated main-handler with ring-buffer access
                    Sa     Modified          ESCAN00027061 All                            Minor DescICN driver optimization
                    Sa     Modified          ESCAN00027063 All                            MainHandler req-/resDataLen has misleading description for CANdescBasic
                    Sa     Modified          ESCAN00027057 All                            Compile error on missing semicolon for DescSetNpmOnCanChannelActive macro expansion
                    Mhe    Added             ESCAN00024011 All                            Support dynamic normal addressing
                    Mhe    Added             ESCAN00024019 All                            Support far RAM Tp API         
                    Mhe    Added             ESCAN00026452 All                            Posthandler support for generated $23
2008-07-11 05.07.01
                    -      -                 -             -                              No relevant changes available in this version.
2008-08-08 05.07.02
                    Sa     Fixed             ESCAN00028409 All                            No response on request         
2008-10-02 05.07.03
                    Ktw    Modified          ESCAN00030418 Porsche AG(UDS)                Positive response of FBL is not sent in certain use cases
                    Sa     Modified          ESCAN00029770 All                            Compiler warning for enumeration item with value 0xFF on enum-type = char
                    Sa     Added             ESCAN00030116 All                            Provide IsoTp-Callback prototypes in desc.h/danisisotp.h
                    Sa     Added             ESCAN00030087 All                            Support of internal diagnostic requests over IsoTP
2008-10-30 05.07.04
                    Sa     Fixed             ESCAN00030759 All                            Generator stops with internal error during processing 'MainHandlerOnProtocolService' that contains muxed component
                    Sa     Fixed             ESCAN00030981 All                            Switch to surpress multitiple addressing check
                    Sa     Fixed             ESCAN00029915 All                            CANdesc files can not be written
                    Sa     Modified          ESCAN00031158 All                            Ring-buffer feature enabled for non-ISO-TP DANIS drivers
                    Sa     Added             ESCAN00031156 All                            Added DANIS abstraction for testerId and comChannel
2008-11-26 05.07.05
                    -      -                 -             -                              No relevant changes available in this version.
2008-12-15 05.07.06
                    Ktw    Fixed             ESCAN00031533 All                            Compiler Warning: Unused variable tpTxChannel
2009-02-02 05.07.07
                    Sa     Fixed             ESCAN00027182 All                            Compiler Warning: variable "svcInstFailedBytePosMask" is possibly uninitialized
2009-02-17 05.07.08
                    -      -                 -             -                              No relevant changes available in this version.
2009-03-09 05.07.09
                    -      -                 -             -                              No relevant changes available in this version.
2009-03-12 05.07.10
                    -      -                 -             -                              No relevant changes available in this version.
2009-03-16 05.07.11
                    -      -                 -             -                              No relevant changes available in this version.
2009-03-16 05.07.12
                    -      -                 -             -                              No relevant changes available in this version.
2009-04-15 05.07.13
                    -      -                 -             -                              No relevant changes available in this version.
2009-05-06 05.07.14
                    Sa     Modified          ESCAN00034880 UDS                            Disable call of DescStateTask() in DescTask() if HIGH_PERFOMANCE_MODE is active
                    Sa     Added             ESCAN00035198 UDS                            New API DescIsSuppressPosResBitSet
                    Sa     Fixed             ESCAN00034934 All                            Wrong null-terminated and leading size byte string data object total length calculation
2009-06-19 05.07.15
                    Ktw    Fixed             ESCAN00035554 All                            Null pointer access in DanisBoschTp
2009-07-01 05.07.16
                    -      -                 -             -                              No relevant changes available in this version.
2009-07-13 05.07.17
                    -      -                 -             -                              No relevant changes available in this version.
2009-08-11 05.07.18
                    Sa     Fixed             ESCAN00036995 All                            Compile warning on redeclaration of function DescGetBuffer
                    Sa     Fixed             ESCAN00036138 All                            Compiler warning on redundant declaration of DescGetBuffer
                    Sa     Modified          ESCAN00036996 All                            Switching between ANSI C and hardware optimized bit-type
                    Sa     Modified          ESCAN00037096 All                            Undo ESCAN00036465             
2009-08-31 05.07.19
                    -      -                 -             -                              No relevant changes available in this version.
2009-10-14 05.07.20
                    -      -                 -             -                              No relevant changes available in this version.
2009-11-17 05.07.21
                    Sa     Fixed             ESCAN00039237 All                            Compiler Warning: possible redundant expression / useless assignment
                    Sa     Modified          ESCAN00040135 All                            CanChannelIdentityAssignment is generated in RAM section
2010-02-02 05.07.22
                    -      -                 -             -                              No relevant changes available in this version.
2010-02-12 05.07.23
                    -      -                 -             -                              No relevant changes available in this version.
2010-05-12 05.07.24
                    Sa     Fixed             ESCAN00042963 All                            DescCopyToCan API does not support CAN message buffers located in the gpage
2010-05-31 05.07.25
                    Sa     Fixed             ESCAN00043021 Porsche AG(UDS)                Compile error for wrong pointer types used in API DescSendSPontaneousResponse
                    Sa     Fixed             ESCAN00041576 All                            Compiler warning for constant expression in DescDispatcher
                    Sa     Fixed             ESCAN00043240 All                            Compiler error for missing data types DescDynDidMemBlockAddress and DescDynDidMemBlockSize
2010-07-16 05.07.26
                    Sa     Fixed             ESCAN00037465 UDS                            Compiler warning: parameter "pMsgContext" not used
                    Sa     Fixed             ESCAN00044189 UDS                            Valid service 0x28 request rejected with negative response
                    Sa     Fixed             ESCAN00044049 UDS                            Compiler warning: condition is always false
                    Sa     Fixed             ESCAN00044050 All                            Compiler warning: condition is always false
                    Sa     Fixed             ESCAN00044197 All                            Not all buffers used in DANIS can be located in far RAM
                    Sa     Added             ESCAN00044127 All                            Support for DANIS adapter specific available buffer size information to the application
2010-08-10 05.07.27
                    Sa     Fixed             ESCAN00044371 All                            v_inc.h is not included in the generated DANIS adapter template
                    Sa     Fixed             ESCAN00044528 All                            Compile errors in DanisIsoTp communication adapter
2010-10-14 05.07.28
                    Ktw    Fixed             ESCAN00045932 All                            Compile error on each usage of DescInterruptDisable/-Restore internal API
2010-10-08 05.07.29
                    Mhe    Fixed             ESCAN00046410 All                            After ECU reset the diagnostic response is not transmitted after the function DescSendPosRespFBL has been called
2010-12-18 05.07.30
                    Sa     Fixed             ESCAN00047355 All                            Memory mapping of FAR buffer support use incomplete description for paged memory µC
                    Ktw    Added             ESCAN00047741 All                            Adapt CANdesc TMS320 support for GENy enabled CANdriver
2011-01-04 05.07.31
                    Ktw    Fixed             ESCAN00047884 All                            ROM data used as function parameter
2011-01-21 05.07.32
                    Ktw    Added             ESCAN00048157 All                            Add Danis adapter for LinTp    
2011-03-07 05.07.33
                    -      -                 -             -                              No relevant changes available in this version.
2011-03-28 05.07.34
                    Sa     Fixed             ESCAN00049396 UDS                            No positive response sent if SPRMIB=TRUE and API DescForceRcrRpResponse is used
                    Sa     Modified          ESCAN00047821 All                            Missing protection of undefined V_MEMRAM3_FAR
                    Sa     Modified          ESCAN00048636 All                            Error message references non-existent file "ApplDesc.h"
2011-05-13 05.07.35
                    Sa     Fixed             ESCAN00050204 UDS                            CANdesc does not reject requested service 0x2C 0x02 with ALFID==0x00
2011-05-31 05.07.36
                    Ktw    Fixed             ESCAN00051088 UDS                            Service 0x2A 0x04 ends up with endless RCR-RP responses on asynchronously read periodic DIDs
                    Ktw    Added             ESCAN00051315 UDS                            API DescGetCurrentBusInfo should be usable for periodic transmission 
2011-09-14 05.07.37
                    -      -                 -             -                              No relevant changes available in this version.
------------------------------------------------------------------------------------------------------------------------
 */


/* -----------------------------------------------------------------------------
    &&&~ Includes
 ----------------------------------------------------------------------------- */

/* Physical layer specific API */
#include "v_inc.h"
/* Check if CCL is available and take into account its configuration */
#if defined (VGEN_ENABLE_CCL)
# include "ccl_cfg.h"
#endif

/* Check if CCLcom is available and take into account its configuration */
#if defined (VGEN_ENABLE_CCLCOM)
# include "cclcom_cfg.h"
#endif

/* Make all CANdesc specific typedefs available */
#include "desc.h"
/* Include the implementation prototypes for prototype checks */
#include "appdesc.h"

/* Required for the implementation of ApplDescInitPosResFblBusInfo */
#include "tpmc.h"

#include <stdlib.h>
#include "deh.h"


#include "EEPROM.h"
#include "EEPROM_LAYOUT_CFG.h"

#include "APP_DESC.h"
#include "Diag_ReqHandling.h"
#include "Diag_Service_22.h"
#include "Diag_Service_2E.h"
#include "APP_COMMON_Utils.h"
#include "TRACE.h"
#include "appdesc.id"
#define DIAG_A_DTCStatusAvailabilityMask     0x19         /* 0x19 for ECUs without Warning Lamp */
                                                         /* 0x99 for ECUs with Warning Lamp */
                                                         /* 0xDF for OBD ECUs */

DiagMsgContextType gDiagMsgContext;
extern DiagnoseContextType gDiagnoseContext;
/* -----------------------------------------------------------------------------
    &&&~ Implementation
 ----------------------------------------------------------------------------- */

#if defined (DESC_ENABLE_DEBUG_USER ) || defined (DESC_ENABLE_DEBUG_INTERNAL)
# if defined (CCL_ENABLE_ERROR_HOOK) || defined (CCLCOM_ENABLE_ERROR_HOOK)
/* CCL takes care about this function */
# else
/* ********************************************************************************
 * Function name:ApplDescFatalError
 * Description: This function will be called each time while the debug mode is active a
 * CANdesc fault has been detected. If you reach this function it makes no sence to continue the tests since CANdesc
 * will not operate properly until next start of the ECU.
 * Returns:  nothing
 * Parameter(s):
 *   - errorCode:
 *       - The assert code text equivalent can be found in desc.h (kDescAssert....).
 *       - Access type: read
 *   - lineNumber:
 *       - Since the same fault could be cales on many places the line number shows where exactly it occured.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - Set a break point at this place to know during the ECU development if you ran onto it.
 ******************************************************************************** */
void DESC_API_CALLBACK_TYPE ApplDescFatalError(vuint8 errorCode, vuint16 lineNumber)
{
  /*<<TBD>> Remove this comment once you have completely implemented this function!!!*/
  /* Avoid warnings */
  DESC_IGNORE_UNREF_PARAM(errorCode);
  DESC_IGNORE_UNREF_PARAM(lineNumber);

  /* When fatal error occurs, cause an ECU hang up at this point.
   * Please set break point at this line to investigate both parameter values. */
  for(;;);
}
# endif
#endif

/*******************************************************************************
* NAME:              ApplDescInitPosResFblBusInfo
*
* CALLED BY:         CANdesc
* PRECONDITIONS:     
*
* DESCRIPTION:       Initializes the busInfo with the concrete response address information
*                    (e.g. sourceAddr,TargetAddr, COM channel, etc.).
*******************************************************************************/
vuint8 DESC_API_CALL_TYPE ApplDescInitPosResFblBusInfo(t_descUsdtNetBus* pBusInfo)
{
  /* Init the bus-info structure as shown below */
  pBusInfo->busType = kDescUsdtNetBusTypeIsoTp;/* on other bus systems use the apropriate bus-type */
  /*On multi channel systems */
  pBusInfo->comChannel = 0; /* set the CAN (FlexRay or other) channel on which to send */
  /* If the addressing scheme uses source/target addresses put here the tester addres to respond to */
  pBusInfo->testerId = 0xF1; /* set the CAN (FlexRay or other) channel on which to send */

#if defined(DESC_USDTNET_ENABLE_DYNAMIC_BUFFER_LENGTH)
  /* If dynamic length is used, please use the correct buffer size of the corresponding DANIS driver!!! */
  pBusInfo->availBufferLength = kDescPrimBufferLen;
#endif

#if ( defined (TP_ENABLE_DYNAMIC_CHANNELS) && \
    (defined(TP_ENABLE_MIXED_11_ADDRESSING) || \
    defined(TP_ENABLE_NORMAL_ADDRESSING)) )
  /* ********** for these use cases additional TPMC initalization is required ********** */
  {
    vuintx tpChannel = kTpTxChannelCount;
    while (tpChannel != 0)
    {
      tpChannel--;
      if (kDescDiagConnection == TpTxGetConnectionNumber(tpChannel))
      {
# if defined(TP_ENABLE_MULTIPLE_ADDRESSING)
        tpTxInfoStruct[tpChannel].assignedDestination = kTpRequestDiagPhysical;
        tpTxInfoStruct[tpChannel].addressingFormat = kTpNormalAddressing; /*... respectively: kTpMixed11Addressing */
# endif
# error "Replace the <DIAG_NORMAL_ADD_RES_ID> and <DIAG_NORMAL_ADD_REQ_ID> below with the real CANids and uncomment the line!"
        /* TpTxSetChannelID(tpChannel, <DIAG_NORMAL_ADD_RES_ID>, <DIAG_NORMAL_ADD_REQ_ID>); */
# if (kTpNumberOfCanChannels > 1)
        TpTxSetCanChannel(tpChannel, pBusInfo->comChannel);
# endif
        break;
      }
    }
  }
#endif
  return kDescOk;
}

/*  ********************************************************************************
 * Function name:ApplDescOnTransitionSession
 * Description:Notification function for state change of the given state group, defined by
 * CANdelaStudio.
 * Returns:  nothing
 * Parameter(s):
 *   - newState:
 *       - The state which will be set.
 *       - Access type: read
 *   - formerState:
 *       - The current state of this state group.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" may not be called.
 *   - The function "DescSetNegResponse" may not be called.
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescOnTransitionSession(DescStateGroup newState, DescStateGroup formerState)
{
  /* <<TBD>> Remove this comment once you have completely implemented this function!!! */
   /* This is only a notification function. Using the "formerState" and the "newState" 
   * parameter you can distinguish the different transitions for this state group.
   */
  /* Avoids warnings */
  DESC_IGNORE_UNREF_PARAM(newState);
  DESC_IGNORE_UNREF_PARAM(formerState);
  (void)DEH_SetDiagnosticSession(newState);
;
}


/* ********************************************************************************
 * Function name:ApplDescGlobalServicePreHandler
 * Description: Notification function that the a valid service has been received 
 *              (except for service $3E - TesterPresent).
 * Returns:  none
 * Parameter(s):
 *   - iContext - CANdesc instance handle (if multi instanced CANdesc is used)
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" may not be called.
 *   - The function "DescSetNegResponse" can be called.
 ******************************************************************************** */
void DESC_API_CALLBACK_TYPE ApplDescGlobalServicePreHandler(DESC_CONTEXT_FORMAL_PARAM_DEF_ONLY)
{
  /* Use this function to disable the rapid-shut-down state. */
}

/*  ********************************************************************************
 * Function name:ApplDescProcessEcuReset (Service request header:$11 )
 * Description: not available 
 * Returns:  nothing
 * Parameter(s):
 *   - pMsgContext->reqData:
 *       - Points to the first service request data byte.
 *       - Access type: read
 *   - pMsgContext->resData:
 *       - Points to the first writeable byte for the service response data.
 *       - Access type: read/write
 *   - pMsgContext->reqDataLen:
 *       - Contains the count of the service request data bytes (Sid and sub-parameters are excluded).
 *       - Access type: read
 *   - pMsgContext->resDataLen:
 *       - Must be initialized with the count of the service response data bytes (Sid and sub-parameters are excluded).
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.reqType:
 *       - Shows the addressing type of the request (kDescPhysReq or kDescFuncReq).
 *       - Access type: read
 *   - pMsgContext->msgAddInfo.resOnReq:
 *       - Indicates if there will be response. Allowed only to write only 0 !!!
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.suppPosRes:
 *       - UDS only!If set no positive response will be sent on this request.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" must be called from now on (within this
 * main-handler or later).
 *   - The function "DescSetNegResponse" can be called within this main-handler or later
 * but before calling "DescProcessingDone".
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescProcessEcuReset(DescMsgContext* pMsgContext)
{
    if( pMsgContext->reqDataLen != 1 )
    {
        DescSetNegResponse(kDescNrcInvalidFormat);
        DescProcessingDone();
        return;
    }
    if ((gDiagnoseContext.securityState & MASK_SEC_ACTIVE) != MASK_SEC_ACTIVE)
    {
        DescSetNegResponse(kDescNrcAccessDenied);
    }
    else
    {
        DEBUG_VALUE1(DIAG_SWI_TRC, MOD_DIAG, "ApplDescProcessEcuReset: resetType = %d", pMsgContext->reqData[0]);
        switch( pMsgContext->reqData[0] )
        {
            case UDS_11_HardReset:
            {
                pMsgContext->resDataLen = 1;
                pMsgContext->resData[0] = pMsgContext->reqData[0];
                gDiagnoseContext.resetControl = UDS_11_HardReset;
                break;
            }
            case UDS_11_KeyOffOnReset:
            {
                pMsgContext->resDataLen = 1;
                pMsgContext->resData[0] = pMsgContext->reqData[0];
                gDiagnoseContext.resetControl = UDS_11_KeyOffOnReset;
                break;
            }
            case UDS_11_EnableRapidPowerShutDownSequence:
            {
                pMsgContext->resDataLen = 2;
                pMsgContext->resData[0] = pMsgContext->reqData[0];
                pMsgContext->resData[1] = UDS_11_TimeToPowerDown;   /* time to reset */
                gDiagnoseContext.resetControl = UDS_11_TimeToPowerDown;
                break;
            }
            case UDS_11_DisableRapidPowerShutDownSequence:
            {
                pMsgContext->resDataLen = 1;
                pMsgContext->resData[0] = pMsgContext->reqData[0];
                gDiagnoseContext.resetControl = UDS_11_DisableRapidPowerShutDownSequence;
                break;
            }
            case UDS_11_SoftReset:
            default:
                DescSetNegResponse(kDescNrcSubfunctionNotSupported);
                break;
        }
    }
    /* User service processing finished. */
    DescProcessingDone();
}


/*  ********************************************************************************
 * Function name:ApplDescProcessClearDiagnosticInformation (Service request header:$14 )
 * Description: not available 
 * Returns:  nothing
 * Parameter(s):
 *   - pMsgContext->reqData:
 *       - Points to the first service request data byte.
 *       - Access type: read
 *   - pMsgContext->resData:
 *       - Points to the first writeable byte for the service response data.
 *       - Access type: read/write
 *   - pMsgContext->reqDataLen:
 *       - Contains the count of the service request data bytes (Sid and sub-parameters are excluded).
 *       - Access type: read
 *   - pMsgContext->resDataLen:
 *       - Must be initialized with the count of the service response data bytes (Sid and sub-parameters are excluded).
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.reqType:
 *       - Shows the addressing type of the request (kDescPhysReq or kDescFuncReq).
 *       - Access type: read
 *   - pMsgContext->msgAddInfo.resOnReq:
 *       - Indicates if there will be response. Allowed only to write only 0 !!!
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.suppPosRes:
 *       - UDS only!If set no positive response will be sent on this request.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" must be called from now on (within this
 * main-handler or later).
 *   - The function "DescSetNegResponse" can be called within this main-handler or later
 * but before calling "DescProcessingDone".
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescProcessClearDiagnosticInformation(DescMsgContext* pMsgContext)
{
    tDEH_Return retval = DEH_OK;
    tDEH_DTCGroup dtc = 0;
    if (pMsgContext->reqDataLen != 4)
    {
        dtc  = (vuint32)pMsgContext->reqData[0] << 16;
        dtc += (vuint32)pMsgContext->reqData[1] << 8;
        dtc += pMsgContext->reqData[2];
        DEBUG_VALUE4(DIAG_SWI_TRC, MOD_DIAG, "ApplDescProcessClearDiagnosticInformation request 0x%X 0x%X 0x%X %c",
                     pMsgContext->reqData[0],
                     pMsgContext->reqData[1],
                     pMsgContext->reqData[2],
                     ' ');

        retval = DEH_ClearDiagnosticInformation((tDEH_DTCGroup)dtc);
        DEBUG_STATE1(DIAG_SWI_TRC, MOD_DIAG, "ApplDescProcessClearDiagnosticInformation return value from DEH = %d", retval);
        switch (retval)
        {
            case DEH_OK:
                //TODO: Set timer an send succesful DescProcessingDone() at this timeout Event
                //(void)SetRelAlarm();
                /* User service processing finished. */
                DescProcessingDone();
                break;
            case DEH_E_INIT:
                DescSetNegResponse(kDescNrcConditionsNotCorrect);
                /* User service processing finished. */
                DescProcessingDone();
                break;
            case DEH_E_UNKNOWN_DTCGROUP:
                DescSetNegResponse(kDescNrcRequestOutOfRange);
                /* User service processing finished. */
                DescProcessingDone();
                break;
            case DEH_E_BUSY:
            case DEH_E_CLEAR:
            default:
                DescSetNegResponse(kDescNrcConditionsNotCorrect);
                /* User service processing finished. */
                DescProcessingDone();
                break;
        }
    }
    else
    {
        /* Request length invalid - send negative response! */
        DescSetNegResponse(kDescNrcInvalidFormat);
        /* User service processing finished. */
        DescProcessingDone();
    }
}


/*  ********************************************************************************
 * Function name:ApplDescProcessReadDtcInformation (Service request header:$19 )
 * Description: not available 
 * Returns:  nothing
 * Parameter(s):
 *   - pMsgContext->reqData:
 *       - Points to the first service request data byte.
 *       - Access type: read
 *   - pMsgContext->resData:
 *       - Points to the first writeable byte for the service response data.
 *       - Access type: read/write
 *   - pMsgContext->reqDataLen:
 *       - Contains the count of the service request data bytes (Sid and sub-parameters are excluded).
 *       - Access type: read
 *   - pMsgContext->resDataLen:
 *       - Must be initialized with the count of the service response data bytes (Sid and sub-parameters are excluded).
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.reqType:
 *       - Shows the addressing type of the request (kDescPhysReq or kDescFuncReq).
 *       - Access type: read
 *   - pMsgContext->msgAddInfo.resOnReq:
 *       - Indicates if there will be response. Allowed only to write only 0 !!!
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.suppPosRes:
 *       - UDS only!If set no positive response will be sent on this request.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" must be called from now on (within this
 * main-handler or later).
 *   - The function "DescSetNegResponse" can be called within this main-handler or later
 * but before calling "DescProcessingDone".
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescProcessReadDtcInformation(DescMsgContext* pMsgContext)
{
    #define DTCInformationType          pMsgContext->reqData[0]
    #define DTCStatusMask               pMsgContext->reqData[1]
    #define DTCExtendedDataRecordNumber pMsgContext->reqData[4]
	tDEH_Return retVal = DEH_OK;
	tDEH_DTCAndStatus das;
	vuint32 dtc;
	vuint16 index=0;

    if (pMsgContext->reqDataLen != 0)
    {
        dtc  = (vuint32)pMsgContext->reqData[1] << 16;
        dtc += (vuint32)pMsgContext->reqData[2] << 8;
        dtc += pMsgContext->reqData[3];

	    DEBUG_VALUE1(DIAG_SWI_TRC, MOD_DIAG, ">> Get DTCInformationType=0x%04X request from Tester", DTCInformationType);
	    switch( DTCInformationType )
	    {
	        /* Read DTC and status */
	        case UDS_19_ReportDTCByStatusMask:
#if( DIAG_A_DTCStatusAvailabilityMask == 0xDF )
		    case UDS_19_ReportEmissionRelatedOBDDTCByStatusMask:
#endif
            {
		        if( 2 == pMsgContext->reqDataLen )
		        {
                    pMsgContext->resData[0] = pMsgContext->reqData[0];
                    pMsgContext->resData[1] = pMsgContext->reqData[1];
		            index = 2;
		            do
		            {
			            retVal = DEH_ReadDTCByStatus( (tDEH_DTCInfoType)DTCInformationType,(tDEH_DTCStatusMask)DTCStatusMask, &das);
			            DEBUG_VALUE1(DIAG_SWI_TRC, MOD_DIAG, "das.DTC=0x%06X", das.DTC);
			            DEBUG_VALUE2(DIAG_SWI_TRC, MOD_DIAG, "Get DTCStatusMask request from Tester=0x%02X, Internal das.StatusOfDTC =0x%02X get from DEH",
                                     DTCStatusMask, das.StatusOfDTC);
			            DEBUG_VALUE1(DIAG_SWI_TRC, MOD_DIAG, "(DTCStatusMask & (das.StatusOfDTC & DIAG_A_DTCStatusAvailabilityMask)=0x%04X",
                                     DTCStatusMask & (das.StatusOfDTC & DIAG_A_DTCStatusAvailabilityMask));
			            /* Looking in VW80124 for UHV only DTC support for kind of type with the Status 0x19 (DTCStatusAvailabilityMask
			              - For systems without warning lamp ) is needed. First read the internal state DTCs (give all internal DTCs States back)
			              and mask it out with DTCStatusAvailabilityMask. The result have now to compare with the DTCStatusMask request from the
			              tester ((DTCStatusMask & result). Is this new result now not zero DTC Information (DTC list) have to give back to tester.
			              Otherwise a empty list. The internal Status of DTC when give back to tester have mask out again with DTCStatusAvailabilityMask
			              because UHV have only support DTcs with type 0x19 (DTCStatusAvailabilityMask) */
			            if (((das.StatusOfDTC & DIAG_A_DTCStatusAvailabilityMask) & DTCStatusMask)== 0)
			            {
                            DEBUG_TEXT(DIAG_SWI_TRC, MOD_DIAG, "DTCStatusMask & (das.StatusOfDTC & DIAG_A_DTCStatusAvailabilityMask) not match.");
			            }
			            else
			            {
                            if( (retVal == DEH_OK) || (retVal == DEH_E_DATA_STILL_AVAILABLE) )
                            {
                                pMsgContext->resData[index+0] = (vuint8)(das.DTC>>16);
                                pMsgContext->resData[index+1] = (vuint8)(das.DTC>>8);
                                pMsgContext->resData[index+2] = (vuint8)(das.DTC);
                                /* das.StatusOfDTC is the internal StatusOfDTC get from DEH
                                   Because UHV have support only that Stati of DTC that defined in DIAG_A_DTCStatusAvailabilityMask
                                   das.StatusOfDTC is mask out with DIAG_A_DTCStatusAvailabilityMask */
                                pMsgContext->resData[index+3] = das.StatusOfDTC & DIAG_A_DTCStatusAvailabilityMask;
                                DEBUG_VALUE1(DIAG_SWI_TRC, MOD_DIAG, "StatusOfDTC=0x%02X goes to Tester", pMsgContext->resData[index+3]);
                                index += 4; /* sizeof(tDEH_DTCAndStatus); */
                                if( (index+4) > kDescPrimBufferLen ) /* check if buffer space available for the next DTC+status */
                                {
                                    retVal = DEH_OK; /* stop collecting */
                                }
                            }
			            }
		            }
		            while( retVal == DEH_E_DATA_STILL_AVAILABLE );
		            pMsgContext->resData[1] = DIAG_A_DTCStatusAvailabilityMask;
		            pMsgContext->resDataLen = index;
		        }
                else
                {
                    DescSetNegResponse(kDescNrcInvalidFormat);
                }
		        break;
            }
#ifdef DEH_SUP_SNAP_SHOT_DATA
		    case UDS_19_ReportDTCSnapshotRecordByDTCNumber:
            {
		        if( 4 == pMsgContext->reqDataLen )
		        {
		            retVal = DEH_ReadDTCSnapshotRecord( (tDEH_DTC)dtc, (uint8_t*)&pMsgContext->reqData[4], (uint16_t)kDescPrimBufferLen-5, (uint16_t*)&index, (uint8_t*)&pMsgContext->resData[5] );
		            pMsgContext->resDataLen = index+5;
		        }
                else
                {
                    DescSetNegResponse(kDescNrcInvalidFormat);
                }
		        break;
            }
#endif
		    /* Read freeze frames */
	        case UDS_19_ReportDTCExtendedDataRecordByDTCNumber:
            {
		        if( 5 == pMsgContext->reqDataLen )
		        {
		            switch( DTCExtendedDataRecordNumber )
		            {
		                case UDS_19_StandardDTCInformation:
		                case UDS_19_StandardFreezeFrame_1:
		                case UDS_19_AllStandardFreezeFrameAndStandardDTCInformation:
#if( DIAG_A_DTCStatusAvailabilityMask == 0xDF )
			            case UDS_19_AllOBDExtendedDataRecordNumbers:
#endif
		                case UDS_19_AllDTCExtendedDataRecordNumbers:
                            pMsgContext->resData[0] = pMsgContext->reqData[0];
                            pMsgContext->resData[1] = pMsgContext->reqData[1];
                            pMsgContext->resData[2] = pMsgContext->reqData[2];
                            pMsgContext->resData[3] = pMsgContext->reqData[3];
                            /* DEH_ReadDTCExtDataRecord write info pMsgContext->resData[x] data. This information goes back to Vas Tester */
                            retVal = DEH_ReadDTCExtDataRecord((tDEH_DTC)dtc,
                                                              (uint8_t*)&pMsgContext->reqData[4],
                                                              (tDEH_RecordNumber)DTCExtendedDataRecordNumber,
                                                              (uint16_t)kDescPrimBufferLen-5,
                                                              (uint16_t*)&index,
                                                              (uint8_t*)&pMsgContext->resData[5]);
                            DEBUG_VALUE1(DIAG_SWI_TRC, MOD_DIAG, "Internal das.StatusOfDTC =0x%02X get from DEH",pMsgContext->resData[4]);
                            /*  In RxTxBuf[4] is now the internal StatusOfDTC get from DEH
                                Because UHV have support only that Stati of DTC that defined in SDS_A_DTCStatusAvailabilityMask
                                RxTxBuf[4] is mask out with SDS_A_DTCStatusAvailabilityMask */
                            pMsgContext->resData[4] = pMsgContext->reqData[4] & DIAG_A_DTCStatusAvailabilityMask;
                            DEBUG_VALUE1(DIAG_SWI_TRC, MOD_DIAG, "StatusOfDTC=0x%02X goes to Tester", pMsgContext->resData[4]);
                            pMsgContext->resDataLen = index+5;
                            break;
		                default:
                            DescSetNegResponse(kDescNrcRequestOutOfRange);
                            break;
		            }
                }
                else
                {
                    DescSetNegResponse(kDescNrcInvalidFormat);
                }
		        break;
            }
		    /* unsupported subfunction */
	        default:
                DescSetNegResponse(kDescNrcSubfunctionNotSupported);
                break;
	    }
        DEBUG_STATE1(DIAG_SWI_TRC, MOD_DIAG, "ApplDescProcessReadDtcInformation return value from DEH = %d", retVal);
        switch (retVal)
        {
            case DEH_OK:
            case DEH_E_NO_DATA:
                /* Positive response */
                break;
            case DEH_E_BUSY:
            case DEH_E_INIT:
                DescSetNegResponse(kDescNrcBusyRepeatRequest);
                break;
            case DEH_E_WRONG_DIAG_SESSION:
                DescSetNegResponse(kDescNrcSubfunctionNotSupportedInActiveSession);
                break;
            case DEH_E_NO_BUFFER:
            case DEH_E_READ_MEMORY:
                DescSetNegResponse(kDescNrcConditionsNotCorrect);
                break;
            default:
                DescSetNegResponse(kDescNrcRequestOutOfRange);
                break;
        }
    }
    else
    {
        DescSetNegResponse(kDescNrcInvalidFormat);
    }
    /* User service processing finished. */
    DescProcessingDone();
}


/*  ********************************************************************************
 * Function name:ApplDescProcessReadDataByIdentifier (Service request header:$22 )
 * Description: not available 
 * Returns:  nothing
 * Parameter(s):
 *   - pMsgContext->reqData:
 *       - Points to the first service request data byte.
 *       - Access type: read
 *   - pMsgContext->resData:
 *       - Points to the first writeable byte for the service response data.
 *       - Access type: read/write
 *   - pMsgContext->reqDataLen:
 *       - Contains the count of the service request data bytes (Sid and sub-parameters are excluded).
 *       - Access type: read
 *   - pMsgContext->resDataLen:
 *       - Must be initialized with the count of the service response data bytes (Sid and sub-parameters are excluded).
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.reqType:
 *       - Shows the addressing type of the request (kDescPhysReq or kDescFuncReq).
 *       - Access type: read
 *   - pMsgContext->msgAddInfo.resOnReq:
 *       - Indicates if there will be response. Allowed only to write only 0 !!!
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.suppPosRes:
 *       - UDS only!If set no positive response will be sent on this request.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" must be called from now on (within this
 * main-handler or later).
 *   - The function "DescSetNegResponse" can be called within this main-handler or later
 * but before calling "DescProcessingDone".
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescProcessReadDataByIdentifier(DescMsgContext* pMsgContext)
{
	vuint8 i, elementCount = 0;
	vuint8 n, NumberOfDids, CurrentDid;
	vuint16 uwIdx, awDid[8];

    (void)memset((void *)&gDiagMsgContext, 0, sizeof(DiagMsgContextType));

	if( pMsgContext->reqDataLen < 2 ) /* at least one DID expected */
	{
        DescSetNegResponse(kDescNrcInvalidFormat);
        DescProcessingDone();
        return;
	}
	else if( (pMsgContext->reqDataLen & 0x1) > 0 ) /* check if lenght is even */
	{
        DescSetNegResponse(kDescNrcInvalidFormat);
        DescProcessingDone();
        return;
	}
	else if( pMsgContext->msgAddInfo.reqType == 0x1 )
	{
		if( pMsgContext->reqDataLen > 16 ) /* max number of identifier = 8 */
		{
            DescSetNegResponse(kDescNrcRequestOutOfRange);
            DescProcessingDone();
            return;
		}
	}
	else
    {
        if( pMsgContext->reqDataLen > 6 ) /* max number of identifier = 3 */
	    {
            DescSetNegResponse(kDescNrcRequestOutOfRange);
            DescProcessingDone();
            return;
	    }
    }
    DEBUG_VALUE1(DIAG_SWI_TRC, MOD_DIAG, "ApplDescProcessReadDataByIdentifier DID-Length = %d", pMsgContext->reqDataLen);
	for( n=0; n<pMsgContext->reqDataLen; n+=2 )
	{
	    awDid[n/2] = (pMsgContext->reqData[n] << 8) + pMsgContext->reqData[n+1]; /* save DIDs temporary */
        DEBUG_VALUE1(DIAG_SWI_TRC, MOD_DIAG, "ApplDescProcessReadDataByIdentifier DID = $%04X", awDid[n/2]);
	}
	NumberOfDids = n/2;

	CurrentDid = 0;
	uwIdx = 0;

	while( CurrentDid < NumberOfDids )
	{
		vuint8 lower, upper, found;
		lower=0; found = 0; i = 0;
		upper=(sizeof(cs_ReadDataIdItem)/sizeof(t_ReadDataIdCfgItem))-1;
        DEBUG_VALUE1(DIAG_SWI_TRC, MOD_DIAG, "ApplDescProcessReadDataByIdentifier last DID = %d", upper);
		/* lower,i = first DID; upper = last DID */

		while( i < upper ) /* stop searching if border reached */
		{
			/* get next interval */
			if( awDid[CurrentDid] < cs_ReadDataIdItem[i].DataId )
			{
				upper = i; /* update upper border */
			}
			else
			{
				lower = i; /* update lower border */
			}
			i = (upper-lower); /* calculate the middle */
			i = lower + i/2 + i%2; /* of lower and upper border */
			if( cs_ReadDataIdItem[i].DataId == awDid[CurrentDid] )
			{
				found = 1; /* data identifier found */
				break; /* stop searching */
			}
			if( i == lower ) /* check for termination condition */
			{
				if( awDid[CurrentDid] == cs_ReadDataIdItem[i+1].DataId )
				{
					found = 1; /* data identifier found */
					i++;
				}
				break; /* stop searching */
			}
			if( i == upper ) /* check for termination condition */
			{
				if( awDid[CurrentDid] == cs_ReadDataIdItem[i-1].DataId)
				{
					found = 1; /* data identifier found */
					i--;
				}
				break; /* stop searching */
			}
		}
		if( found != 0 ) /* insert data into the buffer if DID found */
		{
            DEBUG_VALUE2(DIAG_SWI_TRC, MOD_DIAG, "ApplDescProcessReadDataByIdentifier DID = 0x%04X, TableIdx = %d", awDid[CurrentDid], i);

            /* save id into buffer for found ids */
            gDiagMsgContext.reqType = DIAG_REQ_READ_BY_IDENTIFIER;
            gDiagMsgContext.data[elementCount].data = &(pMsgContext->resData[uwIdx+2]);
            gDiagMsgContext.data[elementCount].idx = i;
            elementCount += 1;
            gDiagMsgContext.elements = elementCount;
            gDiagMsgContext.counter = 0;
			pMsgContext->resData[uwIdx] = (vuint8)(awDid[CurrentDid] >> 8);
			pMsgContext->resData[uwIdx+1] = (vuint8)awDid[CurrentDid];
			uwIdx += cs_ReadDataIdItem[i].Len+2;
		}
		CurrentDid ++;
	}
	if( uwIdx > 0 )
	{
		pMsgContext->resDataLen = uwIdx;
        gDiagnoseContext.DiagnoseRequestState = DIAG_REQ_SEARCHING_DID_STATE;
        (void)APP_COMMON_UTILS_stSetOsekRelAlarm(CTA_HOST_HANDLE_DIAG_REQ, MSEC(5), 0);
        //DescProcessingDone();
	}
	else
	{
		/* DID not supported at all */
        DescSetNegResponse(kDescNrcRequestOutOfRange);
        DescProcessingDone();
	}
}
/*  ********************************************************************************
 * Function name:ApplDescProcessReadMemoryByAddress (Service request header:$23 )
 * Description: not available 
 * Returns:  nothing
 * Parameter(s):
 *   - pMsgContext->reqData:
 *       - Points to the first service request data byte.
 *       - Access type: read
 *   - pMsgContext->resData:
 *       - Points to the first writeable byte for the service response data.
 *       - Access type: read/write
 *   - pMsgContext->reqDataLen:
 *       - Contains the count of the service request data bytes (Sid and sub-parameters are excluded).
 *       - Access type: read
 *   - pMsgContext->resDataLen:
 *       - Must be initialized with the count of the service response data bytes (Sid and sub-parameters are excluded).
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.reqType:
 *       - Shows the addressing type of the request (kDescPhysReq or kDescFuncReq).
 *       - Access type: read
 *   - pMsgContext->msgAddInfo.resOnReq:
 *       - Indicates if there will be response. Allowed only to write only 0 !!!
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.suppPosRes:
 *       - UDS only!If set no positive response will be sent on this request.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" must be called from now on (within this
 * main-handler or later).
 *   - The function "DescSetNegResponse" can be called within this main-handler or later
 * but before calling "DescProcessingDone".
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescProcessReadMemoryByAddress(DescMsgContext* pMsgContext)
{
  /* <<TBD>> Remove this comment once you have completely implemented this function!!! */
  /* The application must check the requested data length. */
  if(pMsgContext->reqDataLen <= (DescMsgLen)0x0FFF)
  {
    /* Dummy example how to access the request data. */
    /* Assumming the FIRST DATA byte contains important data which has to be less than a constant value. */
    if(pMsgContext->reqData[0] < 0xFF)
    {
      /* Received data is in range process further. */
      /* Dummy example of how to write the response data. */
      pMsgContext->resData[0] = 0xFF;
      /* Always set the correct length of the response data. */
      pMsgContext->resDataLen = 1;
    }
    else
    {
      /* Request contains invalid data - send negative response! */
      //DescSetNegResponse(kDescNrcRequestOutOfRange);
    }
  }
  else
  {
    /* Request length invalid - send negative response! */
    //DescSetNegResponse(kDescNrcInvalidFormat);
  }
  /* User service processing finished. */
  DescProcessingDone();
}


/*  ********************************************************************************
 * Function name:ApplDescProcessSecurityAccess (Service request header:$27 )
 * Description: not available 
 * Returns:  nothing
 * Parameter(s):
 *   - pMsgContext->reqData:
 *       - Points to the first service request data byte.
 *       - Access type: read
 *   - pMsgContext->resData:
 *       - Points to the first writeable byte for the service response data.
 *       - Access type: read/write
 *   - pMsgContext->reqDataLen:
 *       - Contains the count of the service request data bytes (Sid and sub-parameters are excluded).
 *       - Access type: read
 *   - pMsgContext->resDataLen:
 *       - Must be initialized with the count of the service response data bytes (Sid and sub-parameters are excluded).
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.reqType:
 *       - Shows the addressing type of the request (kDescPhysReq or kDescFuncReq).
 *       - Access type: read
 *   - pMsgContext->msgAddInfo.resOnReq:
 *       - Indicates if there will be response. Allowed only to write only 0 !!!
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.suppPosRes:
 *       - UDS only!If set no positive response will be sent on this request.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" must be called from now on (within this
 * main-handler or later).
 *   - The function "DescSetNegResponse" can be called within this main-handler or later
 * but before calling "DescProcessingDone".
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescProcessSecurityAccess(DescMsgContext* pMsgContext)
{
	Uint16Type i = 0;

	DEBUG_VALUE1(DIAG_SWI_TRC, MOD_DIAG,"SECURITY_ACCESS_SEED: State = 0x%02X",pMsgContext->reqData[0]);
	switch (pMsgContext->reqData[0])
    {
	    case UDS_27_SECURITY_ACCESS_SEED_CODING:
	    case UDS_27_SECURITY_ACCESS_SEED_WRITE_READ_BY_ADDRESS:
        {
	        if ( pMsgContext->reqDataLen != 1 )
            {
                DescSetNegResponse(kDescNrcInvalidFormat);
	        }
            else
            {
	            if ((gDiagnoseContext.securityState & MASK_SEC_STATUS_LOCKED) == MASK_SEC_STATUS_LOCKED)
                {
	                /* Start Timer not again */
	                /* TI: 9928 -> Wichtig - Nur bei einem Reset oder Kl.15-Wechsel soll die Sperrzeit neu starten. */
	                DEBUG_VALUE1(DIAG_SWI_TRC, MOD_DIAG,"SECURITY_ACCESS_SEED: Security timer is running!!! ubSecState = %02X",gDiagnoseContext.securityState);
	                DEBUG_VALUE1(DIAG_SWI_TRC, MOD_DIAG,"Security timer is running for %d seconds", (gDiagnoseContext.timerSecurityAccess / 100));
                    DescSetNegResponse(kDescNrcTimeDelayNotExpired);
	            }
                else
                {
	                if ((gDiagnoseContext.securityState & MASK_SEC_ACTIVE) == MASK_SEC_ACTIVE)
                    {
                        (void)memset(gDiagnoseContext.au8Seed, 0, sizeof(gDiagnoseContext.au8Seed));
	                    DEBUG_VALUE1(DIAG_SWI_TRC, MOD_DIAG,"SECURITY_ACCESS_SEED: Set Seed to 0x00000000 ubSecState = %02X",gDiagnoseContext.securityState);
	                }
                    else if ((gDiagnoseContext.securityState & MASK_SEED_ALREADY_SEND) == MASK_SEED_ALREADY_SEND)
                    {
                        /* seed was already sent, thats the reason we sending same seed */
	                    DEBUG_VALUE1(DIAG_SWI_TRC, MOD_DIAG,"SECURITY_ACCESS_SEED: Seed is sendig already, => send again the same Seed ubSecState = %02X",gDiagnoseContext.securityState);
	                }
                    else
                    {
                        srand( (unsigned int)osGetSystemCounter() );
                        for( i = 0; i < 4; i++ )
                        {
                            gDiagnoseContext.au8Seed[i] = (Uint8Type)rand();
                        }
                        DEBUG_VALUE4(DIAG_SWI_TRC, MOD_DIAG,"DIAG_vGenerateSecurityAccessKey generate seed 0x%02x 0x%02x 0x%02x 0x%02x" ,gDiagnoseContext.au8Seed[0],
                                                                                                                      gDiagnoseContext.au8Seed[1],
                                                                                                                       gDiagnoseContext.au8Seed[2],
                                                                                                                        gDiagnoseContext.au8Seed[3]);
                        DIAG_vGenerateSecurityAccessKey();
	                    gDiagnoseContext.securityState |= MASK_SEED_ALREADY_SEND; // dieser Zustand wird nicht ins EEPROM gespeichert, bzw. beim Zurücklesen nach Systemstart ausmaskiert
	                }
	                pMsgContext->resDataLen = 5;
                    pMsgContext->resData[0] = pMsgContext->reqData[0];
                    (void)memcpy((void *)&pMsgContext->resData[1], (const void*)gDiagnoseContext.au8Seed, 4);
	            }
	        }
	        break;
        }
	    case UDS_27_SECURITY_ACCESS_KEY_CODING:
        case UDS_27_SECURITY_ACCESS_KEY_WRITE_READ_BY_ADDRESS:
        {
	        if ( pMsgContext->reqDataLen != 5 )
	        {
                DescSetNegResponse(kDescNrcInvalidFormat);
	        }
	        else if((gDiagnoseContext.securityState & MASK_SEC_STATUS_LOCKED) == MASK_SEC_STATUS_LOCKED)
	        {
	            DEBUG_VALUE1(DIAG_SWI_TRC, MOD_DIAG,"SECURITY_ACCESS_KEY: Security timer is running!!! ubSecState = %02X", gDiagnoseContext.securityState);
                DescSetNegResponse(kDescNrcRequestSequenceError);
	        }
	        else if((gDiagnoseContext.securityState & MASK_SEC_ACTIVE) == MASK_SEC_ACTIVE)
            {
	            DEBUG_VALUE1(DIAG_SWI_TRC, MOD_DIAG,"SECURITY_ACCESS_KEY: Security timer is running!!! ubSecState = %02X", gDiagnoseContext.securityState);
	            gDiagnoseContext.securityState &= ~MASK_SEC_ACTIVE;
                DescSetNegResponse(kDescNrcRequestSequenceError);
            }
	        else if ((gDiagnoseContext.securityState & MASK_SEED_ALREADY_SEND) == MASK_SEED_ALREADY_SEND)
	        {
                DEBUG_VALUE4(DIAG_SWI_TRC, MOD_DIAG,"SECURITY_ACCESS_KEY 0x%02x 0x%02x 0x%02x 0x%02x" ,gDiagnoseContext.au8Key[0],
                                                                                                                      gDiagnoseContext.au8Key[1],
                                                                                                                       gDiagnoseContext.au8Key[2],
                                                                                                                        gDiagnoseContext.au8Key[3]);
                DEBUG_VALUE4(DIAG_SWI_TRC, MOD_DIAG,"SECURITY_ACCESS_KEY response 0x%02x 0x%02x 0x%02x 0x%02x" ,pMsgContext->reqData[1],
                                                                                                                      pMsgContext->reqData[2],
                                                                                                                       pMsgContext->reqData[3],
                                                                                                                        pMsgContext->reqData[4]);
	            if (0 == memcmp((const void *)&pMsgContext->reqData[1], (const void *)&gDiagnoseContext.au8Key[0], 4))
	            {
	                gDiagnoseContext.securityState |= MASK_SEC_ACTIVE;
	                gDiagnoseContext.securityState &= MASK_SEC_STATUS_UNLOCKED; // die Key Sperre wieder aufheben und im EEPROM sichern
	                gDiagnoseContext.timerSecurityAccess = 0;
	                pMsgContext->resDataLen = 1;
	                pMsgContext->resData[0] = pMsgContext->reqData[0]; // eigentlich steht das schon in RxTxBuf[0]
	                DEBUG_VALUE1(DIAG_SWI_TRC, MOD_DIAG,"SECURITY_ACCESS_KEY: Key valid ubSecState = %02X",gDiagnoseContext.securityState);
	            }
                else
                {
	                if (((++gDiagnoseContext.securityState) & MASK_SEED_COUNTER) == MASK_SEED_COUNTER) // Hinweis: ++ubSecState kann kein Überlauf erzeugen, weil dies durch MASK_SEC_STATUS_LOCKED gesichert wird
	                {
	                    DEBUG_TEXT(DIAG_SWI_TRC, MOD_DIAG,"SECURITY_ACCESS_KEY: three times wrong key !!!");
	                    gDiagnoseContext.securityState |= MASK_SEC_STATUS_LOCKED; // dreimal falscher Key => für 10min sperren !!!
	                    gDiagnoseContext.timerSecurityAccess = SECURITY_BLOCKING_TIME; // tja, und warten...
	                }
	                else
	                {
	                    DEBUG_VALUE1(DIAG_SWI_TRC, MOD_DIAG,"SECURITY_ACCESS_KEY: key error, attempt = %d",(gDiagnoseContext.securityState & MASK_SEED_COUNTER));
	                }
	                (void)EEPROM_sfRamWriteOnly(&gDiagnoseContext.securityState, EEPROM_LAYOUT_ENUM_SecurityAccessState);
	                DEBUG_VALUE1(DIAG_SWI_TRC, MOD_DIAG, "SECURITY_ACCESS_KEY: ubSecState 0x%02X",  gDiagnoseContext.securityState);
                    DescSetNegResponse(kDescNrcInvalidKey);
	            }
	        }
            else
            {
	            DEBUG_TEXT(DIAG_SWI_TRC, MOD_DIAG,"SECURITY_ACCESS_KEY: no security access");
                DescSetNegResponse(kDescNrcRequestSequenceError);
	        }
	        break;
        }
	    default:
        {
            DescSetNegResponse(kDescNrcSubfunctionNotSupported);
            break;
        }
	}
    DescProcessingDone();
}

/*  ********************************************************************************
 * Function name:ApplDescProcessWriteDataByIdentifier (Service request header:$2E )
 * Description: not available 
 * Returns:  nothing
 * Parameter(s):
 *   - pMsgContext->reqData:
 *       - Points to the first service request data byte.
 *       - Access type: read
 *   - pMsgContext->resData:
 *       - Points to the first writeable byte for the service response data.
 *       - Access type: read/write
 *   - pMsgContext->reqDataLen:
 *       - Contains the count of the service request data bytes (Sid and sub-parameters are excluded).
 *       - Access type: read
 *   - pMsgContext->resDataLen:
 *       - Must be initialized with the count of the service response data bytes (Sid and sub-parameters are excluded).
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.reqType:
 *       - Shows the addressing type of the request (kDescPhysReq or kDescFuncReq).
 *       - Access type: read
 *   - pMsgContext->msgAddInfo.resOnReq:
 *       - Indicates if there will be response. Allowed only to write only 0 !!!
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.suppPosRes:
 *       - UDS only!If set no positive response will be sent on this request.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" must be called from now on (within this
 * main-handler or later).
 *   - The function "DescSetNegResponse" can be called within this main-handler or later
 * but before calling "DescProcessingDone".
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescProcessWriteDataByIdentifier(DescMsgContext* pMsgContext)
{
	Uint8Type i;
	Uint16Type u16ReceivedID = ((Uint16Type)pMsgContext->reqData[0] << 8) + pMsgContext->reqData[1];
	Uint8Type lower, upper;
	BooleanType found = BT_FALSE;
	Uint16Type u16ReceivedLen = pMsgContext->reqDataLen - 2; // "-2" weil die CAN-Nutzdaten auch den Identifier enthalten

    (void)memset((void *)&gDiagMsgContext, 0, sizeof(DiagMsgContextType));

	lower=0;
	i = 0;

	upper=(sizeof(cs_WriteDataIdItem)/sizeof(t_WriteDataIdCfgItem))-1;
	/* lower,i = first DID; upper = last DID */
	// die Überprüfung auf '-1' soll mögliche Fehlerquellen beseitigen,z.B. cs_WriteDataIdItem = 0.
	if (upper == 0xFF)
    { // 0xFF = -1
		upper = 0;
    }

	while (i < upper) /* stop searching if border reached */
	{
		/* get next interval */
		if (u16ReceivedID < cs_WriteDataIdItem[i].DataId)
		{
			upper = i; /* update upper border */
		}
		else
		{
			lower = i; /* update lower border */
		}
		i = (upper-lower); /* calculate the middle */
		i = lower + i/2 + i%2; /* of lower and upper border */
		if (cs_WriteDataIdItem[i].DataId == u16ReceivedID)
		{
			found = BT_TRUE; /* data identifier found */
			break; /* stop searching */
		}
		if (i == lower) /* check for termination condition */
		{
			if (u16ReceivedID == cs_WriteDataIdItem[i+1].DataId)
			{
				found = BT_TRUE; /* data identifier found */
				i++;
			}
			break; /* stop searching */
		}
		if (i == upper) /* check for termination condition */
		{
			if (u16ReceivedID == cs_WriteDataIdItem[i-1].DataId)
			{
				found = BT_TRUE; /* data identifier found */
				i--;
			}
			break; /* stop searching */
		}
	}

	if (found == BT_TRUE) /* insert data into the buffer if Data ID found */
	{
		if ( (u16ReceivedLen + 2) <= 254) // "+2" weil hier der Identifier wieder mit dazu zählt // 255 - 1
		{
			if (DIAG_2E_bWriteDiagnosisLengthCheck(u16ReceivedLen, &cs_WriteDataIdItem[i]) == BT_FALSE)
			{
                DescSetNegResponse(kDescNrcInvalidFormat);
                DescProcessingDone();
                return;
			}
            DEBUG_VALUE2(DIAG_SWI_TRC, MOD_DIAG, "ApplDescProcessWriteDataByIdentifier DID = 0x%04X, TableIdx = %d", cs_WriteDataIdItem[i].DataId, i);

            /* save id into buffer for found ids */
            gDiagMsgContext.reqType = DIAG_REQ_WRITE_BY_IDENTIFIER;
            gDiagMsgContext.data[0].data = &(pMsgContext->reqData[2]);
            gDiagMsgContext.data[0].idx = i;
            gDiagMsgContext.data[0].len = u16ReceivedLen;
		    pMsgContext->resData[0] = pMsgContext->reqData[0];
		    pMsgContext->resData[1] = pMsgContext->reqData[1];
		    pMsgContext->resDataLen = 2;
            (void)APP_COMMON_UTILS_stSetOsekRelAlarm(CTA_HOST_HANDLE_DIAG_REQ, MSEC(5), 0);
		}
		else
		{
            DEBUG_VALUE1(DIAG_SWI_TRC, MOD_DIAG, "ApplDescProcessWriteDataByIdentifier Len out of range %d", u16ReceivedLen + 2);
            DescSetNegResponse(kDescNrcRequestOutOfRange);
            DescProcessingDone();
		}
	}
	else
	{
		DEBUG_VALUE2(DIAG_SWI_TRC, MOD_DIAG, "Service2E: value not found!!! %04X instead of %04X",
				cs_WriteDataIdItem[i].DataId, u16ReceivedID);
        DescSetNegResponse(kDescNrcRequestOutOfRange);
        DescProcessingDone();
	}
}


/*  ********************************************************************************
 * Function name:ApplDescProcessInputOutputControlByIdentifier (Service request header:$2F )
 * Description: not available 
 * Returns:  nothing
 * Parameter(s):
 *   - pMsgContext->reqData:
 *       - Points to the first service request data byte.
 *       - Access type: read
 *   - pMsgContext->resData:
 *       - Points to the first writeable byte for the service response data.
 *       - Access type: read/write
 *   - pMsgContext->reqDataLen:
 *       - Contains the count of the service request data bytes (Sid and sub-parameters are excluded).
 *       - Access type: read
 *   - pMsgContext->resDataLen:
 *       - Must be initialized with the count of the service response data bytes (Sid and sub-parameters are excluded).
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.reqType:
 *       - Shows the addressing type of the request (kDescPhysReq or kDescFuncReq).
 *       - Access type: read
 *   - pMsgContext->msgAddInfo.resOnReq:
 *       - Indicates if there will be response. Allowed only to write only 0 !!!
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.suppPosRes:
 *       - UDS only!If set no positive response will be sent on this request.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" must be called from now on (within this
 * main-handler or later).
 *   - The function "DescSetNegResponse" can be called within this main-handler or later
 * but before calling "DescProcessingDone".
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescProcessInputOutputControlByIdentifier(DescMsgContext* pMsgContext)
{
  /* <<TBD>> Remove this comment once you have completely implemented this function!!! */
  /* The application must check the requested data length. */
  if(pMsgContext->reqDataLen <= (DescMsgLen)0x0FFF)
  {
    /* Dummy example how to access the request data. */
    /* Assumming the FIRST DATA byte contains important data which has to be less than a constant value. */
    if(pMsgContext->reqData[0] < 0xFF)
    {
      /* Received data is in range process further. */
      /* Dummy example of how to write the response data. */
      pMsgContext->resData[0] = 0xFF;
      /* Always set the correct length of the response data. */
      pMsgContext->resDataLen = 1;
    }
    else
    {
      /* Request contains invalid data - send negative response! */
      //DescSetNegResponse(kDescNrcRequestOutOfRange);
    }
  }
  else
  {
    /* Request length invalid - send negative response! */
    //DescSetNegResponse(kDescNrcInvalidFormat);
  }
  /* User service processing finished. */
  DescProcessingDone();
}


/*  ********************************************************************************
 * Function name:ApplDescProcessRoutineControl (Service request header:$31 )
 * Description: not available 
 * Returns:  nothing
 * Parameter(s):
 *   - pMsgContext->reqData:
 *       - Points to the first service request data byte.
 *       - Access type: read
 *   - pMsgContext->resData:
 *       - Points to the first writeable byte for the service response data.
 *       - Access type: read/write
 *   - pMsgContext->reqDataLen:
 *       - Contains the count of the service request data bytes (Sid and sub-parameters are excluded).
 *       - Access type: read
 *   - pMsgContext->resDataLen:
 *       - Must be initialized with the count of the service response data bytes (Sid and sub-parameters are excluded).
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.reqType:
 *       - Shows the addressing type of the request (kDescPhysReq or kDescFuncReq).
 *       - Access type: read
 *   - pMsgContext->msgAddInfo.resOnReq:
 *       - Indicates if there will be response. Allowed only to write only 0 !!!
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.suppPosRes:
 *       - UDS only!If set no positive response will be sent on this request.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" must be called from now on (within this
 * main-handler or later).
 *   - The function "DescSetNegResponse" can be called within this main-handler or later
 * but before calling "DescProcessingDone".
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescProcessRoutineControl(DescMsgContext* pMsgContext)
{
  /* <<TBD>> Remove this comment once you have completely implemented this function!!! */
  /* The application must check the requested data length. */
  if(pMsgContext->reqDataLen <= (DescMsgLen)0x0FFF)
  {
    /* Dummy example how to access the request data. */
    /* Assumming the FIRST DATA byte contains important data which has to be less than a constant value. */
    if(pMsgContext->reqData[0] < 0xFF)
    {
      /* Received data is in range process further. */
      /* Dummy example of how to write the response data. */
      pMsgContext->resData[0] = 0xFF;
      /* Always set the correct length of the response data. */
      pMsgContext->resDataLen = 1;
    }
    else
    {
      /* Request contains invalid data - send negative response! */
      //DescSetNegResponse(kDescNrcRequestOutOfRange);
    }
  }
  else
  {
    /* Request length invalid - send negative response! */
    //DescSetNegResponse(kDescNrcInvalidFormat);
  }
  /* User service processing finished. */
  DescProcessingDone();
}


/*  ********************************************************************************
 * Function name:ApplDescProcessRequestDownload (Service request header:$34 )
 * Description: not available 
 * Returns:  nothing
 * Parameter(s):
 *   - pMsgContext->reqData:
 *       - Points to the first service request data byte.
 *       - Access type: read
 *   - pMsgContext->resData:
 *       - Points to the first writeable byte for the service response data.
 *       - Access type: read/write
 *   - pMsgContext->reqDataLen:
 *       - Contains the count of the service request data bytes (Sid and sub-parameters are excluded).
 *       - Access type: read
 *   - pMsgContext->resDataLen:
 *       - Must be initialized with the count of the service response data bytes (Sid and sub-parameters are excluded).
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.reqType:
 *       - Shows the addressing type of the request (kDescPhysReq or kDescFuncReq).
 *       - Access type: read
 *   - pMsgContext->msgAddInfo.resOnReq:
 *       - Indicates if there will be response. Allowed only to write only 0 !!!
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.suppPosRes:
 *       - UDS only!If set no positive response will be sent on this request.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" must be called from now on (within this
 * main-handler or later).
 *   - The function "DescSetNegResponse" can be called within this main-handler or later
 * but before calling "DescProcessingDone".
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescProcessRequestDownload(DescMsgContext* pMsgContext)
{
  /* <<TBD>> Remove this comment once you have completely implemented this function!!! */
  /* The application must check the requested data length. */
  if(pMsgContext->reqDataLen <= (DescMsgLen)0x0FFF)
  {
    /* Dummy example how to access the request data. */
    /* Assumming the FIRST DATA byte contains important data which has to be less than a constant value. */
    if(pMsgContext->reqData[0] < 0xFF)
    {
      /* Received data is in range process further. */
      /* Dummy example of how to write the response data. */
      pMsgContext->resData[0] = 0xFF;
      /* Always set the correct length of the response data. */
      pMsgContext->resDataLen = 1;
    }
    else
    {
      /* Request contains invalid data - send negative response! */
      //DescSetNegResponse(kDescNrcRequestOutOfRange);
    }
  }
  else
  {
    /* Request length invalid - send negative response! */
    //DescSetNegResponse(kDescNrcInvalidFormat);
  }
  /* User service processing finished. */
  DescProcessingDone();
}


/*  ********************************************************************************
 * Function name:ApplDescProcessRequestUpload (Service request header:$35 )
 * Description: not available 
 * Returns:  nothing
 * Parameter(s):
 *   - pMsgContext->reqData:
 *       - Points to the first service request data byte.
 *       - Access type: read
 *   - pMsgContext->resData:
 *       - Points to the first writeable byte for the service response data.
 *       - Access type: read/write
 *   - pMsgContext->reqDataLen:
 *       - Contains the count of the service request data bytes (Sid and sub-parameters are excluded).
 *       - Access type: read
 *   - pMsgContext->resDataLen:
 *       - Must be initialized with the count of the service response data bytes (Sid and sub-parameters are excluded).
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.reqType:
 *       - Shows the addressing type of the request (kDescPhysReq or kDescFuncReq).
 *       - Access type: read
 *   - pMsgContext->msgAddInfo.resOnReq:
 *       - Indicates if there will be response. Allowed only to write only 0 !!!
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.suppPosRes:
 *       - UDS only!If set no positive response will be sent on this request.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" must be called from now on (within this
 * main-handler or later).
 *   - The function "DescSetNegResponse" can be called within this main-handler or later
 * but before calling "DescProcessingDone".
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescProcessRequestUpload(DescMsgContext* pMsgContext)
{
  /* <<TBD>> Remove this comment once you have completely implemented this function!!! */
  /* The application must check the requested data length. */
  if(pMsgContext->reqDataLen <= (DescMsgLen)0x0FFF)
  {
    /* Dummy example how to access the request data. */
    /* Assumming the FIRST DATA byte contains important data which has to be less than a constant value. */
    if(pMsgContext->reqData[0] < 0xFF)
    {
      /* Received data is in range process further. */
      /* Dummy example of how to write the response data. */
      pMsgContext->resData[0] = 0xFF;
      /* Always set the correct length of the response data. */
      pMsgContext->resDataLen = 1;
    }
    else
    {
      /* Request contains invalid data - send negative response! */
      //DescSetNegResponse(kDescNrcRequestOutOfRange);
    }
  }
  else
  {
    /* Request length invalid - send negative response! */
    //DescSetNegResponse(kDescNrcInvalidFormat);
  }
  /* User service processing finished. */
  DescProcessingDone();
}


/*  ********************************************************************************
 * Function name:ApplDescProcessTransferData (Service request header:$36 )
 * Description: not available 
 * Returns:  nothing
 * Parameter(s):
 *   - pMsgContext->reqData:
 *       - Points to the first service request data byte.
 *       - Access type: read
 *   - pMsgContext->resData:
 *       - Points to the first writeable byte for the service response data.
 *       - Access type: read/write
 *   - pMsgContext->reqDataLen:
 *       - Contains the count of the service request data bytes (Sid and sub-parameters are excluded).
 *       - Access type: read
 *   - pMsgContext->resDataLen:
 *       - Must be initialized with the count of the service response data bytes (Sid and sub-parameters are excluded).
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.reqType:
 *       - Shows the addressing type of the request (kDescPhysReq or kDescFuncReq).
 *       - Access type: read
 *   - pMsgContext->msgAddInfo.resOnReq:
 *       - Indicates if there will be response. Allowed only to write only 0 !!!
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.suppPosRes:
 *       - UDS only!If set no positive response will be sent on this request.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" must be called from now on (within this
 * main-handler or later).
 *   - The function "DescSetNegResponse" can be called within this main-handler or later
 * but before calling "DescProcessingDone".
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescProcessTransferData(DescMsgContext* pMsgContext)
{
  /* <<TBD>> Remove this comment once you have completely implemented this function!!! */
  /* The application must check the requested data length. */
  if(pMsgContext->reqDataLen <= (DescMsgLen)0x0FFF)
  {
    /* Dummy example how to access the request data. */
    /* Assumming the FIRST DATA byte contains important data which has to be less than a constant value. */
    if(pMsgContext->reqData[0] < 0xFF)
    {
      /* Received data is in range process further. */
      /* Contains no response data */
    }
    else
    {
      /* Request contains invalid data - send negative response! */
      //DescSetNegResponse(kDescNrcRequestOutOfRange);
    }
  }
  else
  {
    /* Request length invalid - send negative response! */
    //DescSetNegResponse(kDescNrcInvalidFormat);
  }
  /* User service processing finished. */
  DescProcessingDone();
}


/*  ********************************************************************************
 * Function name:ApplDescProcessRequestTransferExit (Service request header:$37 )
 * Description: not available 
 * Returns:  nothing
 * Parameter(s):
 *   - pMsgContext->reqData:
 *       - Points to the first service request data byte.
 *       - Access type: read
 *   - pMsgContext->resData:
 *       - Points to the first writeable byte for the service response data.
 *       - Access type: read/write
 *   - pMsgContext->reqDataLen:
 *       - Contains the count of the service request data bytes (Sid and sub-parameters are excluded).
 *       - Access type: read
 *   - pMsgContext->resDataLen:
 *       - Must be initialized with the count of the service response data bytes (Sid and sub-parameters are excluded).
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.reqType:
 *       - Shows the addressing type of the request (kDescPhysReq or kDescFuncReq).
 *       - Access type: read
 *   - pMsgContext->msgAddInfo.resOnReq:
 *       - Indicates if there will be response. Allowed only to write only 0 !!!
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.suppPosRes:
 *       - UDS only!If set no positive response will be sent on this request.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" must be called from now on (within this
 * main-handler or later).
 *   - The function "DescSetNegResponse" can be called within this main-handler or later
 * but before calling "DescProcessingDone".
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescProcessRequestTransferExit(DescMsgContext* pMsgContext)
{
  /* <<TBD>> Remove this comment once you have completely implemented this function!!! */
  /* The application must check the requested data length. */
  if(pMsgContext->reqDataLen <= (DescMsgLen)0x0FFF)
  {
    /* Dummy example how to access the request data. */
    /* Assumming the FIRST DATA byte contains important data which has to be less than a constant value. */
    if(pMsgContext->reqData[0] < 0xFF)
    {
      /* Received data is in range process further. */
      /* Contains no response data */
    }
    else
    {
      /* Request contains invalid data - send negative response! */
      //DescSetNegResponse(kDescNrcRequestOutOfRange);
    }
  }
  else
  {
    /* Request length invalid - send negative response! */
    //DescSetNegResponse(kDescNrcInvalidFormat);
  }
  /* User service processing finished. */
  DescProcessingDone();
}


/*  ********************************************************************************
 * Function name:ApplDescProcessWriteMemoryByAddress (Service request header:$3D )
 * Description: not available 
 * Returns:  nothing
 * Parameter(s):
 *   - pMsgContext->reqData:
 *       - Points to the first service request data byte.
 *       - Access type: read
 *   - pMsgContext->resData:
 *       - Points to the first writeable byte for the service response data.
 *       - Access type: read/write
 *   - pMsgContext->reqDataLen:
 *       - Contains the count of the service request data bytes (Sid and sub-parameters are excluded).
 *       - Access type: read
 *   - pMsgContext->resDataLen:
 *       - Must be initialized with the count of the service response data bytes (Sid and sub-parameters are excluded).
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.reqType:
 *       - Shows the addressing type of the request (kDescPhysReq or kDescFuncReq).
 *       - Access type: read
 *   - pMsgContext->msgAddInfo.resOnReq:
 *       - Indicates if there will be response. Allowed only to write only 0 !!!
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.suppPosRes:
 *       - UDS only!If set no positive response will be sent on this request.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" must be called from now on (within this
 * main-handler or later).
 *   - The function "DescSetNegResponse" can be called within this main-handler or later
 * but before calling "DescProcessingDone".
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescProcessWriteMemoryByAddress(DescMsgContext* pMsgContext)
{
  /* <<TBD>> Remove this comment once you have completely implemented this function!!! */
  /* The application must check the requested data length. */
  if(pMsgContext->reqDataLen <= (DescMsgLen)0x0FFF)
  {
    /* Dummy example how to access the request data. */
    /* Assumming the FIRST DATA byte contains important data which has to be less than a constant value. */
    if(pMsgContext->reqData[0] < 0xFF)
    {
      /* Received data is in range process further. */
      /* Dummy example of how to write the response data. */
      pMsgContext->resData[0] = 0xFF;
      /* Always set the correct length of the response data. */
      pMsgContext->resDataLen = 1;
    }
    else
    {
      /* Request contains invalid data - send negative response! */
      //DescSetNegResponse(kDescNrcRequestOutOfRange);
    }
  }
  else
  {
    /* Request length invalid - send negative response! */
    //DescSetNegResponse(kDescNrcInvalidFormat);
  }
  /* User service processing finished. */
  DescProcessingDone();
}


/*  ********************************************************************************
 * Function name:ApplDescProcessControlDTCSetting (Service request header:$85 )
 * Description: not available 
 * Returns:  nothing
 * Parameter(s):
 *   - pMsgContext->reqData:
 *       - Points to the first service request data byte.
 *       - Access type: read
 *   - pMsgContext->resData:
 *       - Points to the first writeable byte for the service response data.
 *       - Access type: read/write
 *   - pMsgContext->reqDataLen:
 *       - Contains the count of the service request data bytes (Sid and sub-parameters are excluded).
 *       - Access type: read
 *   - pMsgContext->resDataLen:
 *       - Must be initialized with the count of the service response data bytes (Sid and sub-parameters are excluded).
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.reqType:
 *       - Shows the addressing type of the request (kDescPhysReq or kDescFuncReq).
 *       - Access type: read
 *   - pMsgContext->msgAddInfo.resOnReq:
 *       - Indicates if there will be response. Allowed only to write only 0 !!!
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.suppPosRes:
 *       - UDS only!If set no positive response will be sent on this request.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" must be called from now on (within this
 * main-handler or later).
 *   - The function "DescSetNegResponse" can be called within this main-handler or later
 * but before calling "DescProcessingDone".
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescProcessControlDTCSetting(DescMsgContext* pMsgContext)
{
    tDEH_Return retVal = DEH_OK;
    vuint32 dtcType;

    dtcType  = (vuint32)pMsgContext->reqData[1] << 16;
    dtcType += (vuint32)pMsgContext->reqData[2] << 8;
    dtcType += pMsgContext->reqData[3];

    retVal = DEH_ControlDTCSetting( (tDEH_DTCSetType)pMsgContext->reqData[0], (tDEH_TypeOfDTC)dtcType );
    DEBUG_STATE1(DIAG_SWI_TRC, MOD_DIAG, "ApplDescProcessControlDTCSetting return value from DEH = %d", retVal);
    switch (retVal)
    {
        case DEH_OK:
            /* correct response */
            break;
        case DEH_E_UNKNOWN_DTC:
            DescSetNegResponse(kDescNrcRequestOutOfRange);
            break;
        case DEH_E_INIT:
            DescSetNegResponse(kDescNrcBusyRepeatRequest);
            break;
        default:
            DescSetNegResponse(kDescNrcSubfunctionNotSupported);
            break;
    }

    /* User service processing finished. */
    DescProcessingDone();
}


/* ********************************************************************************
 * Function name:ApplDescOnCommunicationDisable
 * Description: Notification function that the communication has been disabled.
 * Returns:  none
 * Parameter(s):none
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" may not be called.
 *   - The function "DescSetNegResponse" may not be called.
 ******************************************************************************** */
void DESC_API_CALLBACK_TYPE ApplDescOnCommunicationDisable(void)
{
  /*<<TBD>> Remove this comment once you have completely implemented this function!!!*/
  /* The requested group of messages will no more be sent onto the communication bus. */
}

/* ********************************************************************************
 * Function name:ApplDescOnCommunicationEnable
 * Description: Notification function that the communication has been restored.
 * Returns:  none
 * Parameter(s):none
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" may not be called.
 *   - The function "DescSetNegResponse" may not be called.
 ******************************************************************************** */
void DESC_API_CALLBACK_TYPE ApplDescOnCommunicationEnable(void)
{
  /*<<TBD>> Remove this comment once you have completely implemented this function!!!*/
  /* The requested group of messages will be able to be sent onto the communication bus. */
}

/* Check the communication control activity */
/* ********************************************************************************
 * Function name:ApplDescCheckCommCtrl
 * Description:Check if the requested communication manipulation is possible to be performed by the ECU.
 * Returns:  nothing
 * Parameter(s):
 *   - iContext:
 *       - Diagnostic request handle used only in multi-context system (kDescNumContexts > 1).
 *       - Access type: read
 *   - commControlInfo->subNetTxNumber:
 *       - The application shall use this parameter to decied on which physical channels the communiaction will be manipulated.
 *       - Access type: read
 *   - commControlInfo->commCtrlChannel:
 *       - The application determines on which channel the communication will be manipulated (kDescCommControlCanCh01 - kDescCommControlCanCh14).
 *       - Access type: write
 *   - commControlInfo->rxPathState:
 *       - Activity type: kDescCommControlStateEnable - enables the communication; kDescCommControlStateDisable - disables it.
 *       - Access type: read
 *   - commControlInfo->txPathState:
 *       - Activity type: kDescCommControlStateEnable - enables the communication; kDescCommControlStateDisable - disables it.
 *       - Access type: read
 *   - commControlInfo->msgTypes:
 *       - Message group: kDescCommControlMsgAppl - application; kDescCommControlMsgNm - NM; 
 *       - Access type: read
 *   - commControlInfo->reqCommChannel:
 *       - The current CAN channel on which the CommControl request is received.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - Call "DescCommCtrlChecked" (here or later) to confirm the check.
 *   - Call "DescSetNegResponse" to reject the service.
 ******************************************************************************** */
void DESC_API_CALLBACK_TYPE ApplDescCheckCommCtrl(DESC_CONTEXT_FORMAL_PARAM_DEF_FIRST DescOemCommControlInfo *commControlInfo)
{
  /*<<TBD>> Remove this comment once you have completely implemented this function!!!*/

#if defined (DESC_ENABLE_COMM_CTRL_SUBNET_SUPPORT)
  switch(commControlInfo->subNetNumber)
  {
    case kDescCommControlSubNetNumAll:/* Enable/Disable all comm channels (CAN, LIN, etc.)*/
      /* Nothing to do - later the ApplDescSetCommMode will enable/disbale the LIN channels if needed. */
      break;
    case kDescCommControlSubNetNumRx:/* Enable/Disable only the request RX comm channel (CAN)*/
      /* Nothing to do - CANdesc handles the CAN channels */
      break;
    default:
      /* Dispatch subnetworks */
      /* Assumed subnet to CAN mapping: 
       * SubNet 1: LIN 
       * SubNet 2: CAN1 
       * SubNet 3: CAN2 
       */
      switch(commControlInfo->subNetNumber)
      {
        case kDescCommControlSubNetNum01:
          /* LIN network */
          commControlInfo->commCtrlChannel = kDescCommControlCanChNone;
          break;
/* The part is only needed if a multi CAN system is designed !!! */
# if defined(DESC_ENABLE_MULTI_CHANNEL_SUPPORT)
        case kDescCommControlSubNetNum02:
          /* CAN1 */
          commControlInfo->commCtrlChannel = kDescCommControlCanCh01;
          break;
        case kDescCommControlSubNetNum03:
          /* CAN2 */
          commControlInfo->commCtrlChannel = kDescCommControlCanCh02;
          break;
# endif
        default:
          /* Subnet numbers out of range */
          //DescSetNegResponse(DESC_CONTEXT_PARAM_FIRST kDescNrcRequestOutOfRange);
          break;
      }
  }
#endif
  /* Confirm the communication status will be accepted. 
   * This can be done later by storing the iContext parameter (if exists) globaly to be able to give the correct acknowledgment.
   */
  DescCommCtrlChecked(DESC_CONTEXT_PARAM_ONLY);
}

#if defined (DESC_ENABLE_COMM_CTRL_SUBNET_SUPPORT)
/* ********************************************************************************
 * Function name:ApplDescSetCommMode
 * Description:Manipulate application specific channels (LIN, MOST, etc.)
 * Returns:  nothing
 * Parameter(s):
 *   - commControlInfo->subNetTxNumber:
 *       - The application shall use this parameter to decied on which physical channels the communiaction will be manipulated.
 *       - Access type: read
 *   - commControlInfo->commCtrlChannel:
 *       - The application determines on which channel the communication will be manipulated (kDescCommControlCanCh01 - kDescCommControlCanCh14).
 *       - Access type: write
 *   - commControlInfo->rxPathState:
 *       - Activity type: kDescCommControlStateEnable - enables the communication; kDescCommControlStateDisable - disables it.
 *       - Access type: read
 *   - commControlInfo->txPathState:
 *       - Activity type: kDescCommControlStateEnable - enables the communication; kDescCommControlStateDisable - disables it.
 *       - Access type: read
 *   - commControlInfo->msgTypes:
 *       - Message group: kDescCommControlMsgAppl - application; kDescCommControlMsgNm - NM; 
 *       - Access type: read
 *   - commControlInfo->reqCommChannel:
 *       - The current CAN channel on which the CommControl request is received.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" may not be called.
 *   - The function "DescSetNegResponse" may not be called.
 ******************************************************************************** */
void DESC_API_CALLBACK_TYPE ApplDescSetCommMode(DescOemCommControlInfo *commControlInfo)
{
  switch(commControlInfo->subNetNumber)
  {
    case kDescCommControlSubNetNumAll:/* Enable/Disable all comm channels (CAN, LIN, etc.)*/
      /* !!! Process application specific channels (e.g. LIN) CAN are already enabled/disabled by CANdesc */
      break;
    case kDescCommControlSubNetNumRx:/* Enable/Disable only the request RX comm channel (CAN)*/
      /* Nothing to do - CANdesc handles the CAN channels */
      break;
    default:
      /* Dispatch subnetworks */
      /* Assumed subnet to CAN mapping: 
       * SubNet 1: LIN 
       * SubNet 2: CAN1 
       * SubNet 3: CAN2 
       */
      switch(commControlInfo->subNetNumber)
      {
        case kDescCommControlSubNetNum01:
          /* LIN network */
          /* !!! Process application specific channels (e.g. LIN)*/
          break;
        case kDescCommControlSubNetNum02:          /* CAN1 */
        case kDescCommControlSubNetNum03:          /* CAN2 */
          /* Nothing to do - CANdesc handles all CANs */
          break;
        default:break;
      }
  }
}
#endif

#if defined (DESC_ENABLE_RX_COMM_CONTROL)
/* ********************************************************************************
 * Function name:ApplDescSetCommModeOnRxPath
 * Description: Manipulates only the RX path on CAN. For the other networks (if any) such LIN, MOST, etc. reffer to the
 *              ApplDescSetCommMode API.
 * Returns:  nothing
 * Parameter(s):
 *   - commControlInfo->subNetTxNumber:
 *       - The application shall use this parameter to decied on which physical channels the communiaction will be manipulated.
 *       - Access type: read
 *   - commControlInfo->commCtrlChannel:
 *       - The application determines on which channel the communication will be manipulated (kDescCommControlCanCh01 - kDescCommControlCanCh14).
 *       - Access type: write
 *   - commControlInfo->rxPathState:
 *       - Activity type: kDescCommControlStateEnable - enables the communication; kDescCommControlStateDisable - disables it.
 *       - Access type: read
*   - commControlInfo->rxPathState: - irrelevant for this API since it processes only the RX path!!!
 *       - Activity type: kDescCommControlStateEnable - enables the communication; kDescCommControlStateDisable - disables it.
 *       - Access type: read
 *   - commControlInfo->msgTypes:
 *       - Message group: kDescCommControlMsgAppl - application; kDescCommControlMsgNm - NM; 
 *       - Access type: read
 *   - commControlInfo->reqCommChannel:
 *       - The current CAN channel on which the CommControl request is received.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" may not be called.
 *   - The function "DescSetNegResponse" may not be called.
 ******************************************************************************** */
void DESC_API_CALLBACK_TYPE ApplDescSetCommModeOnRxPath(DescOemCommControlInfo *commControlInfo)
{
  if((commControlInfo->rxPathState & kDescCommControlStateEnable) != 0)
  {
    /* _DrvCanSetRxOnlineMode(commControlInfo.commCtrlChannel, g_descCommControlInfo.msgTypes); */
  }
  else
  {
    /* _DrvCanSetRxOfflineMode(commControlInfo.commCtrlChannel, g_descCommControlInfo.msgTypes); */
  }
}
#endif

/*  ********************************************************************************
 * Function name:ApplDescCheckSessionTransition
 * Description:Check if the given session transition is allowed or your ECU is currently not
 * able to perform it.
 * Returns:  nothing
 * Parameter(s):
 *   - newState:
 *       - Contains the new state in which the state group will be set.
 *       - Access type: read
 *   - formerState:
 *       - Contains the current state of the state group.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescSessionTransitionChecked" may be called.
 *   - The function "DescSetNegResponse" may be called.
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescCheckSessionTransition(DescStateGroup newState, DescStateGroup formerState)
{
  /* <<TBD>> Remove this comment once you have completely implemented this function!!! */
     /* Avoids warnings */
//  DESC_IGNORE_UNREF_PARAM(newState);

    DEBUG_STATE1(DIAG_SWI_TRC, MOD_DIAG, "ApplDescCheckSessionTransition: current DiagSession = 0x%02x", newState);
    switch (newState)
    {
        case kDescStateSessionDefault:
        case kDescStateSessionProgramming:
            gDiagnoseContext.activeDiagnosticSession = newState;
            break;
        case kDescStateSessionExtended:
            gDiagnoseContext.activeDiagnosticSession = 0x03;
            break;
        case kDescStateSessionEndOfLine:
            gDiagnoseContext.activeDiagnosticSession = 0x40;
            break;
        case kDescStateSessionDevelopment:
            gDiagnoseContext.activeDiagnosticSession = 0x40;
            break;
        default:
            break;
     }
  DESC_IGNORE_UNREF_PARAM(formerState);
  /* Just showing how to reject session transition if necessary. 
   * The negative response code may be other depending on the rejection reason.
   * This can be done later, but just store the iContext parameter (if exists) globaly to be able to give the correct acknowledgment. 
   */
  if (kDescStateSessionECOS == newState)
  {
    DescSetNegResponse(DESC_CONTEXT_PARAM_FIRST kDescNrcServiceNotSupported);
  }
  /* Confirm the session will be accepted. 
   * This can be done later, but just store the iContext parameter (if exists) globaly to be able to give the correct acknowledgment.
   */
  DescSessionTransitionChecked(DESC_CONTEXT_PARAM_ONLY);
}

DescStateGroup ApplDescGetActiveDiagnosticSession(void)
{
    return (gDiagnoseContext.activeDiagnosticSession);
}


